<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ğŸ’› ×—×™-×××ª VOICE | Hai-Emet</title>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/docx/8.5.0/docx.min.js"></script>
    <script src="/static/live-stream-transcriber.js"></script>
    <style>
        /* =========================================
           SITE LANGUAGE SELECTOR
           ========================================= */
        #siteLanguageSelector {
            position: fixed;
            top: 20px;
            left: 20px;
            background: rgba(0,0,0,0.9);
            padding: 8px 12px;
            border-radius: 8px;
            z-index: 30;
            border: 1px solid rgba(255,215,0,0.5);
            backdrop-filter: blur(10px);
        }
        
        #siteLanguageSelector select {
            background: rgba(255,255,255,0.1);
            color: #ffd700;
            border: 1px solid rgba(255,215,0,0.3);
            padding: 4px 8px;
            border-radius: 4px;
            font-size: 12px;
            cursor: pointer;
        }
        
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        
        html, body {
            width: 100%;
            height: 100%;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: #f0f2f5;
            direction: rtl;
        }
        
        .app-container {
            display: flex;
            width: 100%;
            height: 100vh;
        }
        
        /* ============ SIDEBAR PANEL LEFT ============ */
        .voice-panel {
            width: 320px;
            background: white;
            border-left: 1px solid #e0e0e0;
            overflow-y: auto;
            -webkit-overflow-scrolling: touch;
            transition: width 0.3s ease;
            display: flex;
            flex-direction: column;
            box-shadow: -2px 0 10px rgba(0,0,0,0.05);
        }
        
        .voice-panel.open {
            width: 320px;
        }
        
        .panel-header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 15px;
            font-weight: bold;
            text-align: center;
            font-size: 1em;
            white-space: nowrap;
        }
        
        .panel-content {
            flex: 1;
            overflow-y: auto;
            overflow-x: hidden;
            padding: 15px;
            display: flex;
            flex-direction: column;
        }
        
        .section-title {
            font-size: 0.9em;
            font-weight: bold;
            color: #667eea;
            margin: 12px 0 8px 0;
            padding-bottom: 6px;
            border-bottom: 2px solid #667eea;
        }
        
        .transcription-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border: 2px solid #667eea;
            margin-bottom: 12px;
            min-height: 80px;
            max-height: 250px;
            overflow-y: auto;
            word-break: break-word;
            white-space: normal;
            line-height: 1.6;
        }
        
        .transcription-label {
            font-size: 0.75em;
            color: #999;
            font-weight: 600;
            margin-bottom: 6px;
            text-transform: uppercase;
        }
        
        #finalTranscript {
            font-size: 1.05em;
            font-weight: 600;
            color: #000;
            line-height: 2.2;
            word-break: break-word;
            white-space: pre-wrap;
            direction: rtl;
            text-align: right;
            unicode-bidi: plaintext;
            min-height: 40px;
            display: block !important;
            visibility: visible !important;
            opacity: 1 !important;
        }
        
        #finalTranscript:empty::before {
            content: "ğŸ¤ ×”×ª××œ×•×œ ×™×•×¤×™×¢ ×›××Ÿ...";
            color: #999;
            font-weight: normal;
            font-size: 0.9em;
        }
        
        #translatedText {
            font-size: 0.95em;
            color: #667eea;
            font-weight: 500;
            line-height: 2;
            word-break: break-word;
            white-space: pre-wrap;
            direction: rtl;
            text-align: right;
            unicode-bidi: plaintext;
        }
        
        .status-indicator {
            background: white;
            padding: 8px 12px;
            border-radius: 6px;
            font-size: 0.85em;
            text-align: center;
            color: #667eea;
            font-weight: 600;
            margin-bottom: 12px;
            border: 1px solid #e0e0e0;
        }
        
        .control-btn {
            background: white;
            border: 2px solid #667eea;
            color: #667eea;
            padding: 10px 12px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 0.9em;
            font-weight: 600;
            transition: all 0.3s;
            text-align: center;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .control-btn:hover {
            background: #667eea;
            color: white;
        }
        
        .control-btn.recording {
            background: #ff6b6b;
            color: white;
            border-color: #ff6b6b;
            animation: pulse 1s infinite;
        }
        
        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.7; }
        }
        
        .lang-select {
            padding: 10px 12px;
            border-radius: 8px;
            border: 2px solid #667eea;
            background: white;
            color: #667eea;
            font-weight: 600;
            cursor: pointer;
            font-size: 0.9em;
            width: 100%;
            margin-bottom: 8px;
        }
        
        .file-upload-box {
            background: #f8f9fa;
            padding: 12px;
            border-radius: 8px;
            border: 2px dashed #667eea;
            text-align: center;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 8px;
        }
        
        .file-upload-box:hover {
            background: #e9ecef;
            border-color: #764ba2;
        }
        
        .file-upload-box input {
            display: none;
        }
        
        .files-list {
            margin-top: 8px;
        }
        
        .file-item {
            background: #f8f9fa;
            padding: 8px;
            border-radius: 6px;
            margin-bottom: 6px;
            border: 1px solid #e0e0e0;
            font-size: 0.85em;
        }
        
        .file-name {
            font-weight: 600;
            color: #333;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
        }
        
        .file-transcription {
            background: #f0f7f4;
            border: 1px solid #667eea;
            padding: 6px;
            border-radius: 4px;
            margin-top: 4px;
            font-size: 0.8em;
            color: #2e7d32;
            max-height: 80px;
            overflow-y: auto;
        }
        
        /* ============ MAIN CHAT AREA ============ */
        .main-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: white;
        }
        
        .header {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            padding: 20px;
            text-align: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.1);
        }
        
        .header h1 {
            font-size: 2em;
            margin-bottom: 5px;
        }
        
        .header p {
            font-size: 0.9em;
            opacity: 0.95;
        }
        
        .badge {
            display: inline-block;
            background: rgba(255,255,255,0.2);
            padding: 6px 15px;
            border-radius: 20px;
            font-size: 0.85em;
            margin-top: 10px;
        }
        
        .toggle-panel-btn {
            position: fixed;
            top: 20px;
            right: 20px;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 16px;
            border-radius: 25px;
            cursor: pointer;
            font-size: 1.1em;
            font-weight: bold;
            z-index: 100;
            transition: all 0.3s;
        }
        
        .toggle-panel-btn:hover {
            transform: scale(1.05);
        }
        
        .chat-area {
            flex: 1;
            overflow-y: auto;
            padding: 15px;
            background: #f8f9fa;
            display: flex;
            flex-direction: column;
            -webkit-overflow-scrolling: touch;
        }
        
        .message {
            margin-bottom: 12px;
            display: flex;
            animation: fadeIn 0.3s ease-in;
        }
        
        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(10px); }
            to { opacity: 1; transform: translateY(0); }
        }
        
        .message.user {
            justify-content: flex-end;
        }
        
        .message.assistant {
            justify-content: flex-start;
        }
        
        .message-wrapper {
            display: flex;
            flex-direction: column;
        }
        
        .message.user .message-wrapper {
            align-items: flex-end;
        }
        
        .message.assistant .message-wrapper {
            align-items: flex-start;
        }
        
        .message-content {
            max-width: 80%;
            padding: 12px 15px;
            border-radius: 15px;
            line-height: 1.5;
            font-size: 15px;
            font-family: "Segoe UI", Tahoma, Geneva, Verdana, sans-serif;
            direction: rtl;
            text-align: right;
            white-space: pre-wrap;
            word-wrap: break-word;
            overflow-wrap: break-word;
            display: inline-block;
            vertical-align: top;
            unicode-bidi: plaintext;
        }
        
        .message.user .message-content {
            background: #667eea;
            color: white;
            border-bottom-left-radius: 0;
            direction: rtl;
            text-align: right;
            line-height: 1.5;
        }
        
        .message.assistant .message-content {
            background: white;
            color: #333;
            border-bottom-right-radius: 0;
            border: 1px solid #e0e0e0;
            direction: rtl;
            text-align: right;
            line-height: 1.5;
        }
        
        .message-time {
            font-size: 0.65em;
            color: #999;
            padding: 5px 10px;
        }
        
        .input-area {
            padding: 15px;
            background: white;
            border-top: 1px solid #e0e0e0;
        }
        
        .input-wrapper {
            display: flex;
            gap: 10px;
            align-items: center;
        }
        
        input[type="text"] {
            flex: 1;
            padding: 12px 15px;
            border: 2px solid #e0e0e0;
            border-radius: 25px;
            font-size: 1em;
            transition: border-color 0.3s;
        }
        
        input[type="text"]:focus {
            outline: none;
            border-color: #667eea;
        }
        
        .send-btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 12px 20px;
            border-radius: 25px;
            cursor: pointer;
            font-weight: bold;
            white-space: nowrap;
            font-size: 1em;
        }
        
        .empty-files {
            text-align: center;
            color: #999;
            font-size: 0.85em;
            padding: 10px;
        }

        #videoContainer {
            margin-top: 8px;
            display: none;
            border-radius: 8px;
            overflow: hidden;
            background: #000;
        }

        #videoPlayerWrapper {
            width: 100%;
            background: #f8f9fa;
            border-radius: 8px;
            margin-bottom: 8px;
            overflow: hidden;
        }

        #videoPlayer {
            display: none;
            background: #000;
            width: 100%;
            height: auto;
        }

        #videoTranscript {
            line-height: 2;
            font-size: 1.1em;
            color: #FFFFFF;
            text-shadow: 0 0 4px #000000;
            direction: rtl;
            text-align: center;
            padding: 12px;
            min-height: 60px;
            background: rgba(0,0,0,0.8);
            border-radius: 6px;
            white-space: pre-wrap;
            word-wrap: break-word;
        }

        textarea {
            direction: rtl;
            text-align: right;
        }

        /* ============ RESPONSIVE ============ */
        @media (max-width: 768px) {
            .app-container {
                flex-direction: column;
            }
            
            .voice-panel {
                position: fixed;
                right: 0;
                top: 0;
                width: 0;
                height: 100vh;
                z-index: 999;
                border-left: none;
                border-right: 1px solid #e0e0e0;
                transition: width 0.3s ease;
                overflow-y: auto;
                -webkit-overflow-scrolling: touch;
            }
            
            .voice-panel.open {
                width: 80vw !important;
                box-shadow: -3px 0 15px rgba(0,0,0,0.2);
                max-width: 350px;
            }
            
            .main-container {
                width: 100%;
            }

            .toggle-panel-btn {
                top: 10px;
                right: 10px;
                padding: 10px 12px;
                font-size: 1em;
                z-index: 1000;
            }

            .header h1 {
                font-size: 1.5em;
            }

            .header p {
                font-size: 0.8em;
            }

            .message-content {
                max-width: 85%;
            }
            
            /* Device manager visible on mobile */
            #audioDeviceSelect,
            #videoDeviceSelect {
                width: 100%;
                padding: 10px;
                margin: 8px 0;
                font-size: 14px;
            }
        }

        @media (max-width: 480px) {
            .voice-panel.open {
                width: 100vw !important;
                max-width: 100%;
            }
            
            .header h1 {
                font-size: 1.2em;
            }

            .badge {
                font-size: 0.75em;
            }

            .message-content {
                max-width: 90%;
                font-size: 0.95em;
                padding: 10px 12px;
                line-height: 1.9;
            }

            input[type="text"] {
                font-size: 16px;
            }

            .send-btn {
                padding: 10px 16px;
                font-size: 0.9em;
            }

            .control-btn {
                padding: 8px 10px;
                font-size: 0.85em;
            }

            .lang-select {
                font-size: 0.85em;
                padding: 8px 10px;
            }
        }
    </style>
    
    <style>
        /* =========================================
           QUANTUM VISUALIZATION LAYER
           ========================================= */
        #quantumVisualizer {
            position: fixed;
            top: 0;
            left: 0;
            width: 100vw;
            height: 100vh;
            z-index: 0;
            pointer-events: none;
            opacity: 0.3;
        }

        #quantumCore {
            display: none !important;
            /* ×”×¢×™×’×•×œ ×”×•×¡×¨ ×œ×‘×§×©×ª × ×ª× ×™××œ */
        }
        
        @keyframes quantumBreathe {
            0%, 100% { 
                transform: translate(-50%, -50%) scale(1); 
                filter: hue-rotate(0deg);
                opacity: 0.3;
            }
            50% { 
                transform: translate(-50%, -50%) scale(1.15); 
                filter: hue-rotate(180deg);
                opacity: 0.5;
            }
        }

        #quantumCore.quantum-active {
            animation: quantumPulse 0.5s infinite, quantumBreathe 2s infinite;
            box-shadow: 0 0 300px rgba(255,215,0,0.6), 0 0 500px rgba(255,0,64,0.4);
        }
        
        @keyframes quantumPulse {
            0%, 100% { 
                box-shadow: 0 0 100px rgba(255,215,0,0.3), 0 0 200px rgba(255,0,64,0.3);
                border-color: rgba(0,255,255,0.5);
            }
            50% { 
                box-shadow: 0 0 200px rgba(255,215,0,0.6), 0 0 400px rgba(255,0,64,0.6);
                border-color: rgba(255,0,255,0.8);
            }
        }

        #quantumMetrics {
            position: fixed;
            top: 90px;
            left: 20px;
            background: rgba(0,0,0,0.85);
            padding: 12px;
            border-radius: 8px;
            font-size: 11px;
            z-index: 25;
            border: 1px solid rgba(255,0,255,0.5);
            color: #ff00ff;
            font-family: 'Courier New', monospace;
            min-width: 200px;
            backdrop-filter: blur(10px);
        }

        #quantumLangIndicator {
            position: fixed;
            top: 80px;
            left: 20px;
            transform: none;
            background: rgba(0,0,0,0.85);
            padding: 10px 20px;
            border-radius: 20px;
            font-size: 14px;
            z-index: 25;
            border: 1px solid rgba(255,215,0,0.5);
            color: #ffd700;
            backdrop-filter: blur(10px);
            display: none;
            max-width: 300px;
        }
    </style>
</head>
<body>
    <!-- SITE LANGUAGE SELECTOR -->
    <div id="siteLanguageSelector">
        ğŸŒ <select id="siteLangSelect" onchange="changeSiteLanguage()">
            <option value="he">×¢×‘×¨×™×ª</option>
            <option value="en">English</option>
            <option value="es">EspaÃ±ol</option>
            <option value="fr">FranÃ§ais</option>
            <option value="de">Deutsch</option>
            <option value="it">Italiano</option>
            <option value="pt">PortuguÃªs</option>
            <option value="ru">Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
            <option value="ar">Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
            <option value="ja">æ—¥æœ¬èª</option>
            <option value="zh">ä¸­æ–‡</option>
            <option value="ko">í•œêµ­ì–´</option>
            <option value="hi">à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
            <option value="nl">Nederlands</option>
            <option value="pl">Polski</option>
        </select>
    </div>
    
    <!-- QUANTUM VISUALIZATION LAYER -->
    <canvas id="quantumVisualizer"></canvas>
    <div id="quantumCore"></div>
    <div id="quantumLangIndicator">ğŸ” <span id="quantumLangEmoji">ğŸŒ</span> <span id="quantumLangName">××–×”×”...</span> | ×•×“××•×ª: <span id="quantumConfidence">0</span>%</div>
    <div id="quantumMetrics">
        âš¡ Latency: <span id="quantumLatency">0.0000</span>ms<br>
        ğŸ§¬ Binary: <span id="quantumBinary">0101</span><br>
        ğŸŒ Lang: <span id="quantumCurrentLang">he-IL</span><br>
        ğŸ¯ Confidence: <span id="quantumConf">0</span>%
    </div>
    
    <div class="app-container">
        <!-- VOICE PANEL (LEFT) -->
        <div class="voice-panel" id="voicePanel">
            <div class="panel-header">ğŸ¤ ×˜×§×¡×˜ ×‘×–××Ÿ ×××ª</div>
            
            <div class="panel-content">
                <!-- INPUT MODE TOGGLE -->
                <div style="display: flex; gap: 8px; margin-bottom: 12px;">
                    <button class="control-btn" id="voiceMode" onclick="switchMode('voice')" style="flex: 1; background: #667eea; color: white; border: none;">
                        ğŸ¤ ×”×§×œ×˜×”
                    </button>
                    <button class="control-btn" id="textMode" onclick="switchMode('text')" style="flex: 1; border-color: #667eea; color: #667eea;">
                        âŒ¨ï¸ ×”×§×œ×˜
                    </button>
                </div>
                
                <!-- TEXT INPUT SECTION (hidden by default) -->
                <div id="textInputSection" style="display: none; margin-bottom: 12px;">
                    <div class="status-indicator" id="statusIndicatorText" style="margin-bottom: 8px;">
                        âœ… Ready
                    </div>
                    <div style="display: flex; gap: 8px;">
                        <input 
                            type="text" 
                            id="panelTextInput" 
                            placeholder="×›×ª×•×‘ ××©×”×•..."
                            style="flex: 1; padding: 10px; border: 2px solid #667eea; border-radius: 8px; font-family: inherit; direction: rtl; text-align: right;"
                            onkeypress="if(event.key==='Enter') sendMessageFromPanel()"
                        />
                        <button class="send-btn" onclick="sendMessageFromPanel()" style="padding: 10px 15px;">
                            âœ‰ï¸
                        </button>
                    </div>
                </div>
                
                <!-- VOICE RECORDING SECTION (shown by default) -->
                <div id="voiceRecordingSection">
                    <!-- STATUS -->
                    <div class="status-indicator" id="statusIndicatorVoice">
                        âœ… Ready
                    </div>
                    
                    <!-- RECORD BUTTON -->
                    <button class="control-btn" id="recordBtn" onclick="toggleRecording()">
                        ğŸ¤ ×”×§×œ×˜
                    </button>
                    
                    <!-- LIVE STREAMING BUTTON -->
                    <button class="control-btn" id="liveStreamBtn" onclick="toggleLiveStream()" style="border-color: #FF0000; color: #FF0000; margin-top: 8px;">
                        ğŸ”´ ×©×™×“×•×¨ ×—×™
                    </button>
                    
                    <button class="control-btn" onclick="clearTranscription()" style="border-color: #ff9800; color: #ff9800; margin-top: 8px;">
                        ğŸ”„ × ×§×” ×˜×§×¡×˜
                    </button>
                </div>
                
                <!-- DEVICE SELECTION -->
                <div class="section-title">ğŸ”Š ×‘×—×™×¨×ª ×›×¨×˜×™×¡ ×§×•×œ</div>
                <select class="lang-select" id="audioDeviceSelect" onchange="changeAudioDevice()">
                    <option value="">ğŸ”„ ×–×”×•×™ ××•×˜×•××˜×™</option>
                </select>
                
                <div class="section-title">ğŸ“¹ ×‘×—×™×¨×ª ×›×¨×˜×™×¡ ×•×™×“××•</div>
                <select class="lang-select" id="videoDeviceSelect" onchange="changeVideoDevice()">
                    <option value="">ğŸ”„ ×–×”×•×™ ××•×˜×•××˜×™</option>
                </select>
                
                <button class="control-btn" onclick="enumerateDevices()" style="border-color: #00bfff; color: #00bfff; margin-top: 8px;">
                    ğŸ” ×¡×¨×•×§ ×”×ª×§× ×™×
                </button>

                <!-- AUDIO OPTIMIZATION -->
                <div class="section-title" style="margin-top: 12px;">âš™ï¸ ××•×¤×˜×™××™×–×¦×™×” ×§×•×œ</div>
                <div style="font-size: 0.85em; color: #667eea; background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                    <div>ğŸ™ï¸ Noise Suppression: <strong id="noiseSuppression">âœ…</strong></div>
                    <div>ğŸ“Š Auto Gain: <strong id="autoGain">âœ…</strong></div>
                    <div>ğŸ”Š Sample Rate: <strong id="sampleRate">48KHz</strong></div>
                    <div>ğŸ“ˆ Bit Depth: <strong id="bitDepth">16-bit</strong></div>
                </div>

                <!-- VIDEO OPTIMIZATION -->
                <div class="section-title">ğŸ¥ ××•×¤×˜×™××™×–×¦×™×” ×•×™×“××•</div>
                <div style="font-size: 0.85em; color: #667eea; background: #f8f9fa; padding: 10px; border-radius: 6px; margin-bottom: 8px;">
                    <div>ğŸ“¹ Resolution: <strong id="videoResolution">1920x1080</strong></div>
                    <div>âš¡ Frame Rate: <strong id="frameRate">60fps</strong></div>
                    <div>ğŸ’¡ Lighting: <strong id="lighting">Auto</strong></div>
                    <div>ğŸ¯ Focus: <strong id="focus">Auto</strong></div>
                </div>

                <!-- VOICE LANGUAGE -->
                <div class="section-title">×©×¤×ª ×§×•×œ</div>
                <select class="lang-select" id="voiceLang" onchange="changeVoiceLanguage()">
                    <option value="he-IL">ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª (Hebrew)</option>
                    <option value="en-US">ğŸ‡ºğŸ‡¸ English (×× ×’×œ×™×ª)</option>
                    <option value="es-ES">ğŸ‡ªğŸ‡¸ EspaÃ±ol (×¡×¤×¨×“×™×ª)</option>
                    <option value="fr-FR">ğŸ‡«ğŸ‡· FranÃ§ais (×¦×¨×¤×ª×™×ª)</option>
                    <option value="de-DE">ğŸ‡©ğŸ‡ª Deutsch (×’×¨×× ×™×ª)</option>
                    <option value="it-IT">ğŸ‡®ğŸ‡¹ Italiano (××™×˜×œ×§×™×ª)</option>
                    <option value="pt-PT">ğŸ‡µğŸ‡¹ PortuguÃªs (×¤×•×¨×˜×•×’×–×™×ª)</option>
                    <option value="ru-RU">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹ (×¨×•×¡×™×ª)</option>
                    <option value="ar-SA">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ© (×¢×¨×‘×™×ª)</option>
                    <option value="ja-JP">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª (×™×¤× ×™×ª)</option>
                    <option value="zh-CN">ğŸ‡¨ğŸ‡³ ä¸­æ–‡ (×¡×™× ×™×ª)</option>
                    <option value="ko-KR">ğŸ‡°ğŸ‡· í•œêµ­ì–´ (×§×•×¨×™×× ×™×ª)</option>
                    <option value="hi-IN">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€ (×”×™× ×“×™×ª)</option>
                    <option value="nl-NL">ğŸ‡³ğŸ‡± Nederlands (×”×•×œ× ×“×™×ª)</option>
                    <option value="pl-PL">ğŸ‡µğŸ‡± Polski (×¤×•×œ× ×™×ª)</option>
                </select>
                
                <!-- TRANSLATION LANGUAGE -->
                <div class="section-title" style="margin-top: 15px;">×ª×¨×’×•×</div>
                <select class="lang-select" id="translateLang" onchange="changeTranslateLanguage()">
                    <option value="">ğŸŒ ×œ× ×œ×ª×¨×’×</option>
                    <option value="he">ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª</option>
                    <option value="en">ğŸ‡ºğŸ‡¸ English</option>
                    <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                    <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                    <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                    <option value="it">ğŸ‡®ğŸ‡¹ Italiano</option>
                    <option value="pt">ğŸ‡µğŸ‡¹ PortuguÃªs</option>
                    <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                    <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                    <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
                    <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                    <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
                    <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
                    <option value="nl">ğŸ‡³ğŸ‡± Nederlands</option>
                    <option value="pl">ğŸ‡µğŸ‡± Polski</option>
                </select>
                
                <div class="transcription-box" id="translatedBox" style="display: none; margin-top: 12px;">
                    <div class="transcription-label">×ª×¨×’×•× ×‘×–××Ÿ ×××ª</div>
                    <div id="translatedText"></div>
                </div>
                
                <!-- TRANSCRIPTION -->
                <div class="section-title" style="margin-top: 15px;">×˜×¨× ×¡×§×¨×™×¤×¦×™×”</div>
                
                <div class="transcription-box" style="min-height: 200px; max-height: 300px;">
                    <div class="transcription-label">×˜×§×¡×˜ ×‘×–××Ÿ ×××ª</div>
                    <div id="finalTranscript"></div>
                </div>
                
                <!-- FILE MANAGEMENT -->
                <div class="section-title">×©××™×¨×”</div>
                
                <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                    <button class="control-btn" onclick="saveTranscriptionTXT()" style="border-color: #28a745; color: #28a745; margin-bottom: 0;">
                        ğŸ“„ TXT
                    </button>
                    <button class="control-btn" onclick="saveTranscriptionDOCX()" style="border-color: #28a745; color: #28a745; margin-bottom: 0;">
                        ğŸ“‹ DOCX
                    </button>
                </div>
                
                <!-- FILE UPLOADS -->
                <div class="section-title" style="cursor: pointer; user-select: none;" onclick="toggleUploadAccordion(this)">
                    â–¶ ×”×¢×œ××”
                </div>
                
                <div id="uploadAccordion" style="display: none; margin-bottom: 15px;">
                    <div class="file-upload-box" onclick="document.getElementById('audioInput').click()">
                        ğŸµ ×¡××•× ×“ (MP3, WAV, M4A)
                        <input type="file" id="audioInput" accept="audio/*" onchange="handleAudioUpload(event)">
                    </div>
                    
                    <div class="file-upload-box" onclick="document.getElementById('videoInput').click()">
                        ğŸ¬ ×¡×¨×˜ (MP4, WebM, MOV)
                        <input type="file" id="videoInput" accept="video/*" onchange="handleVideoUpload(event)">
                    </div>
                    
                    <div class="file-upload-box" onclick="document.getElementById('txtInput').click()">
                        ğŸ“„ ×˜×§×¡×˜ TXT
                        <input type="file" id="txtInput" accept=".txt" onchange="handleTxtUpload(event)">
                    </div>
                    
                    <div class="file-upload-box" onclick="document.getElementById('docxInput').click()">
                        ğŸ“‹ DOCX Word
                        <input type="file" id="docxInput" accept=".docx" onchange="handleDocxUpload(event)">
                    </div>
                </div>
                
                <!-- FILES LIST -->
                <div class="section-title">×§×‘×¦×™×</div>
                <div id="filesList" class="files-list">
                    <div class="empty-files">××™×Ÿ ×§×‘×¦×™× ×¢×“×™×™×Ÿ</div>
                </div>
                
                <button class="control-btn" onclick="clearAllFiles()" style="border-color: #ff6b6b; color: #ff6b6b;">
                    ğŸ—‘ï¸ ××—×§ ×”×›×œ
                </button>
                
                <!-- ADVANCED: VIDEO/STREAM SECTION -->
                <div class="section-title" style="margin-top: 15px; cursor: pointer; user-select: none;" onclick="toggleStreamAccordion(this)">
                    â–¶ ×•×™×“××• / ×©×“×•×¨ ×—×™
                </div>
                
                <div id="streamAccordion" style="display: none;">
                    <div style="margin-bottom: 8px;">
                        <div style="font-weight: bold; color: #667eea; margin-bottom: 6px;">ğŸ¬ ×¡×•×’×™ ×§×œ×˜:</div>
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                            <button class="control-btn" onclick="showYouTubeInput()" style="border-color: #FF0000; color: #FF0000; margin-bottom: 0; font-size: 0.9em;">
                                ğŸ“º YouTube
                            </button>
                            <button class="control-btn" onclick="showLiveStreamInput()" style="border-color: #00AA00; color: #00AA00; margin-bottom: 0; font-size: 0.9em;">
                                ğŸ“¡ ×©×“×•×¨ ×—×™
                            </button>
                        </div>
                    </div>
                    
                    <div id="youtubeInputArea" style="display: none; margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #FF0000;">
                        <input type="text" id="youtubeURL" placeholder="https://www.youtube.com/watch?v=..." 
                            style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #FF0000; margin-bottom: 8px; font-size: 0.9em;">
                        <button class="control-btn" onclick="loadYouTubeVideo()" style="width: 100%; margin-bottom: 0; border-color: #FF0000; color: #FF0000;">
                            â–¶ ×”×¤×¢×œ YouTube
                        </button>
                    </div>
                    
                    <div id="liveStreamInputArea" style="display: none; margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 8px; border-left: 4px solid #00AA00;">
                        <input type="text" id="streamURL2" placeholder="https://example.com/stream ××• https://example.com/video.mp4" 
                            style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #00AA00; margin-bottom: 8px; font-size: 0.9em;">
                        <button class="control-btn" onclick="loadLiveStream()" style="width: 100%; margin-bottom: 0; border-color: #00AA00; color: #00AA00;">
                            â–¶ ×”×¤×¢×œ ×©×“×•×¨
                        </button>
                    </div>
                    
                    <div style="margin-bottom: 8px; padding: 10px; background: #f8f9fa; border-radius: 8px;">
                        <div style="font-weight: bold; margin-bottom: 6px; color: #667eea;">ğŸ“ ×›×ª×•×‘×™×•×ª/×˜×§×¡×˜:</div>
                        <textarea id="videoSubtitles" placeholder="×”×“×‘×§ ×›×ª×•×‘×™×•×ª ××• ×˜×§×¡×˜ ××”×¡×¨×˜×•×Ÿ..." 
                            style="width: 100%; height: 100px; padding: 8px; border-radius: 6px; border: 1px solid #667eea; resize: vertical; font-size: 0.9em;"></textarea>
                        <button class="control-btn" onclick="processVideoSubtitles()" style="width: 100%; margin-top: 8px; margin-bottom: 0;">
                            âœ… ×¢×“×›×Ÿ ×›×ª×•×‘×™×•×ª
                        </button>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px; margin-bottom: 8px;">
                        <button class="control-btn" id="audioStreamBtn" onclick="startAudioStreaming()" style="border-color: #667eea; color: #667eea; margin-bottom: 0; font-size: 0.9em;">
                            ğŸ™ï¸ ×”×§×œ×˜ ××•×“×™×•
                        </button>
                        <button class="control-btn" onclick="stopAudioStreaming()" style="border-color: #ff6b6b; color: #ff6b6b; margin-bottom: 0; font-size: 0.9em;">
                            â¹ï¸ ×¢×¦×•×¨
                        </button>
                    </div>
                    
                    <div id="videoContainer">
                        <div id="videoPlayerWrapper" style="width: 100%; background: #f8f9fa; border-radius: 8px; margin-bottom: 8px; overflow: hidden;">
                            <video id="videoPlayer" width="100%" height="auto" controls style="background: #000;"></video>
                        </div>
                        
                        <div style="margin-bottom: 8px;">
                            <div style="font-weight: bold; color: #667eea; margin-bottom: 4px;">ğŸŒ ×‘×—×¨ ×©×¤×” ×œ×ª×¨×’×•×:</div>
                            <select id="videoTranslang" onchange="updateVideoTranslation()" 
                                style="width: 100%; padding: 8px; border-radius: 6px; border: 1px solid #667eea; font-size: 0.9em;">
                                <option value="">ğŸŒ ×‘×—×¨ ×©×¤×”</option>
                                <option value="he">ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª</option>
                                <option value="en">ğŸ‡ºğŸ‡¸ English</option>
                                <option value="es">ğŸ‡ªğŸ‡¸ EspaÃ±ol</option>
                                <option value="fr">ğŸ‡«ğŸ‡· FranÃ§ais</option>
                                <option value="de">ğŸ‡©ğŸ‡ª Deutsch</option>
                                <option value="it">ğŸ‡®ğŸ‡¹ Italiano</option>
                                <option value="pt">ğŸ‡µğŸ‡¹ PortuguÃªs</option>
                                <option value="ru">ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹</option>
                                <option value="ar">ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©</option>
                                <option value="ja">ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª</option>
                                <option value="zh">ğŸ‡¨ğŸ‡³ ä¸­æ–‡</option>
                                <option value="ko">ğŸ‡°ğŸ‡· í•œêµ­ì–´</option>
                                <option value="hi">ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€</option>
                                <option value="nl">ğŸ‡³ğŸ‡± Nederlands</option>
                                <option value="pl">ğŸ‡µğŸ‡± Polski</option>
                            </select>
                        </div>
                        
                        <div class="transcription-box" style="min-height: 120px; max-height: 220px; margin-bottom: 8px; background: #1a1a1a; border: 2px solid #FFD700;">
                            <div class="transcription-label" style="color: #FFD700; text-shadow: 0 0 5px #FFD700;">ğŸ“º ×›×ª×•×‘×™×•×ª ×‘×–××Ÿ ×××ª (TV Subtitles)</div>
                            <div id="videoTranscript"></div>
                        </div>
                        
                        <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                            <button class="control-btn" onclick="saveVideoTranscriptTXT()" style="border-color: #28a745; color: #28a745; margin-bottom: 0;">
                                ğŸ“„ ×©××•×¨ TXT
                            </button>
                            <button class="control-btn" onclick="saveVideoTranscriptDOCX()" style="border-color: #28a745; color: #28a745; margin-bottom: 0;">
                                ğŸ“‹ ×©××•×¨ DOCX
                            </button>
                        </div>
                    </div>
                </div>
            </div>
        </div>
        
        <!-- MAIN CHAT AREA -->
        <div class="main-container">
            <button class="toggle-panel-btn" onclick="togglePanel()">
                ğŸ¤
            </button>
            
            <!-- HEADER -->
            <div class="header">
                <h1>ğŸ’› ×—×™-×××ª VOICE</h1>
                <p>Real-Time Transcription + Translation + File Upload</p>
                <div class="badge">
                    ğŸ“ Transcribed | ğŸ”Š No Speech Output | Binary: 0101-0101(0101)
                </div>
            </div>
            
            <!-- CHAT AREA -->
            <div class="chat-area" id="chatArea">
                <div class="message assistant">
                    <div class="message-wrapper">
                        <div class="message-content">
                            ×©×œ×•×! ğŸ’› ×× ×™ ×—×™-×××ª. ×”×§×œ×˜ ×§×•×œ, ×”×¢×œ×” ×§×‘×¦×™×, ××• ×ª×¨×’× ×˜×§×¡×˜ ×‘×–××Ÿ ×××ª!
                        </div>
                        <div class="message-time">×¢×›×©×™×•</div>
                    </div>
                </div>
            </div>
            
            <!-- INPUT AREA -->
            <div class="input-area">
                <div class="input-wrapper">
                    <input 
                        type="text" 
                        id="messageInput" 
                        placeholder="×›×ª×•×‘ ××©×”×•..."
                        autocomplete="off"
                    />
                    <button class="send-btn" onclick="sendMessage()">âœ‰ï¸</button>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // ğŸ™ï¸ SIMPLE RECORDING - no Web Worker needed
        let simpleMediaRecorder = null;
        let simpleAudioChunks = [];
        let simpleStream = null;
        let isSimpleRecording = false;
        let wakeLock = null; // Wake Lock for continuous recording
        
        const API_URL = 'https://haiemetweb.onrender.com/exec';
        const TOKEN = 'chai_emet_cXVhbnR1bV9tYXN0ZXI:Rk9SRVZFUl9RVUFOVFVNXzVEOnZiamZwbWNnNjhp';
        const BINARY_SIG = "0101-0101(0101)";
        
        const LANGUAGES_CONFIG = {
            'he-IL': { name: 'ğŸ‡®ğŸ‡± ×¢×‘×¨×™×ª', emoji: 'ğŸ’›', label: 'Hebrew' },
            'en-US': { name: 'ğŸ‡ºğŸ‡¸ English', emoji: 'ğŸ’™', label: 'English' },
            'es-ES': { name: 'ğŸ‡ªğŸ‡¸ EspaÃ±ol', emoji: 'ğŸŒº', label: 'Spanish' },
            'fr-FR': { name: 'ğŸ‡«ğŸ‡· FranÃ§ais', emoji: 'ğŸ¥', label: 'French' },
            'de-DE': { name: 'ğŸ‡©ğŸ‡ª Deutsch', emoji: 'ğŸº', label: 'German' },
            'it-IT': { name: 'ğŸ‡®ğŸ‡¹ Italiano', emoji: 'ğŸ', label: 'Italian' },
            'pt-PT': { name: 'ğŸ‡µğŸ‡¹ PortuguÃªs', emoji: 'ğŸ–ï¸', label: 'Portuguese' },
            'ru-RU': { name: 'ğŸ‡·ğŸ‡º Ğ ÑƒÑÑĞºĞ¸Ğ¹', emoji: 'â„ï¸', label: 'Russian' },
            'ar-SA': { name: 'ğŸ‡¸ğŸ‡¦ Ø§Ù„Ø¹Ø±Ø¨ÙŠØ©', emoji: 'ğŸŒ™', label: 'Arabic' },
            'ja-JP': { name: 'ğŸ‡¯ğŸ‡µ æ—¥æœ¬èª', emoji: 'ğŸŒ¸', label: 'Japanese' },
            'zh-CN': { name: 'ğŸ‡¨ğŸ‡³ ä¸­æ–‡', emoji: 'ğŸ®', label: 'Chinese' },
            'ko-KR': { name: 'ğŸ‡°ğŸ‡· í•œêµ­ì–´ (South)', emoji: 'ğŸŒŸ', label: 'Korean South' },
            'ko-KP': { name: 'ğŸ‡°ğŸ‡µ ì¡°ì„ ë§ (North)', emoji: 'â­', label: 'Korean North' },
            'hi-IN': { name: 'ğŸ‡®ğŸ‡³ à¤¹à¤¿à¤¨à¥à¤¦à¥€', emoji: 'ğŸ¨', label: 'Hindi' },
            'nl-NL': { name: 'ğŸ‡³ğŸ‡± Nederlands', emoji: 'ğŸŒ·', label: 'Dutch' },
            'pl-PL': { name: 'ğŸ‡µğŸ‡± Polski', emoji: 'ğŸŒ²', label: 'Polish' }
        };
        
        // =========================================
        // SITE TRANSLATION SYSTEM
        // =========================================
        const SITE_TRANSLATIONS = {
            'he': {
                'voicePanel': 'ğŸ¤ ×˜×§×¡×˜ ×‘×–××Ÿ ×××ª',
                'record': '×”×§×œ×˜',
                'liveStream': '×©×™×“×•×¨ ×—×™',
                'clear': '× ×§×” ×˜×§×¡×˜',
                'audioDevice': '×‘×—×™×¨×ª ×›×¨×˜×™×¡ ×§×•×œ',
                'videoDevice': '×‘×—×™×¨×ª ×›×¨×˜×™×¡ ×•×™×“××•',
                'scanDevices': '×¡×¨×•×§ ×”×ª×§× ×™×',
                'voiceLang': '×©×¤×ª ×§×•×œ',
                'translate': '×ª×¨×’×•×',
                'upload': '×”×¢×œ××”',
                'sound': '×¡××•× ×“',
                'video': '×•×™×“××•',
                'youtube': 'YouTube',
                'ready': '××•×›×Ÿ'
            },
            'en': {
                'voicePanel': 'ğŸ¤ Real-time Text',
                'record': 'Record',
                'liveStream': 'Live Stream',
                'clear': 'Clear Text',
                'audioDevice': 'Audio Device',
                'videoDevice': 'Video Device',
                'scanDevices': 'Scan Devices',
                'voiceLang': 'Voice Language',
                'translate': 'Translation',
                'upload': 'Upload',
                'sound': 'Sound',
                'video': 'Video',
                'youtube': 'YouTube',
                'ready': 'Ready'
            },
            'es': {
                'voicePanel': 'ğŸ¤ Texto en Tiempo Real',
                'record': 'Grabar',
                'liveStream': 'TransmisiÃ³n en Vivo',
                'clear': 'Borrar Texto',
                'audioDevice': 'Dispositivo de Audio',
                'videoDevice': 'Dispositivo de Video',
                'scanDevices': 'Escanear Dispositivos',
                'voiceLang': 'Idioma de Voz',
                'translate': 'TraducciÃ³n',
                'upload': 'Subir',
                'sound': 'Sonido',
                'video': 'Video',
                'youtube': 'YouTube',
                'ready': 'Listo'
            },
            'fr': {
                'voicePanel': 'ğŸ¤ Texte en Temps RÃ©el',
                'record': 'Enregistrer',
                'liveStream': 'Diffusion en Direct',
                'clear': 'Effacer le Texte',
                'audioDevice': 'PÃ©riphÃ©rique Audio',
                'videoDevice': 'PÃ©riphÃ©rique VidÃ©o',
                'scanDevices': 'Scanner les Appareils',
                'voiceLang': 'Langue Vocale',
                'translate': 'Traduction',
                'upload': 'TÃ©lÃ©charger',
                'sound': 'Son',
                'video': 'VidÃ©o',
                'youtube': 'YouTube',
                'ready': 'PrÃªt'
            },
            'ar': {
                'voicePanel': 'ğŸ¤ Ù†Øµ ÙÙŠ Ø§Ù„ÙˆÙ‚Øª Ø§Ù„ÙØ¹Ù„ÙŠ',
                'record': 'ØªØ³Ø¬ÙŠÙ„',
                'liveStream': 'Ø¨Ø« Ù…Ø¨Ø§Ø´Ø±',
                'clear': 'Ù…Ø³Ø­ Ø§Ù„Ù†Øµ',
                'audioDevice': 'Ø¬Ù‡Ø§Ø² Ø§Ù„ØµÙˆØª',
                'videoDevice': 'Ø¬Ù‡Ø§Ø² Ø§Ù„ÙÙŠØ¯ÙŠÙˆ',
                'scanDevices': 'Ù…Ø³Ø­ Ø§Ù„Ø£Ø¬Ù‡Ø²Ø©',
                'voiceLang': 'Ù„ØºØ© Ø§Ù„ØµÙˆØª',
                'translate': 'ØªØ±Ø¬Ù…Ø©',
                'upload': 'Ø±ÙØ¹',
                'sound': 'ØµÙˆØª',
                'video': 'ÙÙŠØ¯ÙŠÙˆ',
                'youtube': 'ÙŠÙˆØªÙŠÙˆØ¨',
                'ready': 'Ø¬Ø§Ù‡Ø²'
            }
        };
        
        let currentSiteLang = 'he';
        
        function changeSiteLanguage() {
            const select = document.getElementById('siteLangSelect');
            currentSiteLang = select.value;
            
            const translations = SITE_TRANSLATIONS[currentSiteLang] || SITE_TRANSLATIONS['en'];
            
            // Update main buttons
            const recordBtn = document.getElementById('recordBtn');
            if (recordBtn && !recordBtn.classList.contains('recording')) {
                recordBtn.innerHTML = 'ğŸ¤ ' + translations.record;
            }
            
            const liveStreamBtn = document.getElementById('liveStreamBtn');
            if (liveStreamBtn && !liveStreamBtn.classList.contains('recording')) {
                liveStreamBtn.innerHTML = 'ğŸ”´ ' + translations.liveStream;
            }
            
            // Save preference
            localStorage.setItem('hai_emet_site_lang', currentSiteLang);
            
            addMessage(`ğŸŒ ×©×¤×ª ×××©×§ ×©×•× ×ª×” ×œ-${select.options[select.selectedIndex].text}`, false);
        }
        
        // Load saved site language
        window.addEventListener('DOMContentLoaded', () => {
            const savedSiteLang = localStorage.getItem('hai_emet_site_lang');
            if (savedSiteLang) {
                const select = document.getElementById('siteLangSelect');
                if (select) {
                    select.value = savedSiteLang;
                    currentSiteLang = savedSiteLang;
                }
            }
        });
        
        // =========================================
        // QUANTUM LANGUAGE DETECTOR
        // =========================================
        class ChaiEmetQuantumLanguageDetector {
            constructor() {
                // ××¤×ª Unicode ranges ×œ×–×™×”×•×™ ××”×™×¨
                this.unicodeLangRanges = {
                    '\u0590-\u05FF': 'he-IL', // ×¢×‘×¨×™×ª
                    '\u0041-\u005A\u0061-\u007A': 'en-US', // ×× ×’×œ×™×ª
                    '\u00C0-\u00FF': 'fr-FR', // ×¦×¨×¤×ª×™×ª
                    '\u0400-\u04FF': 'ru-RU', // ×¨×•×¡×™×ª
                    '\u0600-\u06FF': 'ar-SA', // ×¢×¨×‘×™×ª
                    '\u3040-\u309F\u30A0-\u30FF': 'ja-JP', // ×™×¤× ×™×ª
                    '\u4E00-\u9FFF': 'zh-CN', // ×¡×™× ×™×ª
                    '\uAC00-\uD7AF': 'ko-KR', // ×§×•×¨×™×× ×™×ª
                    '\u0900-\u097F': 'hi-IN', // ×”×•×“×™×ª
                    '\u0100-\u017F': 'pl-PL', // ×¤×•×œ× ×™×ª
                };
                
                this.latencyHistory = [];
                this.worker = null;
                this.setupWorker();
            }
            
            // =========================================
            // Web Worker ×œ×¢×™×‘×•×“ ×§×•×•× ×˜×™
            // =========================================
            setupWorker() {
                try {
                    const workerCode = `
                        let processingTime = 0;
                        self.onmessage = function(e) {
                            const start = performance.now();
                            const { command, data } = e.data;
                            
                            if (command === 'detectLanguage') {
                                // ×¡×™××•×œ×¦×™×” ×©×œ ×¢×™×‘×•×“ ×§×•×•× ×˜×™
                                const binaryPattern = 0b01010101;
                                const processed = data.length * binaryPattern;
                                const latency = performance.now() - start;
                                
                                postMessage({ 
                                    type: 'languageDetected', 
                                    latency: latency,
                                    binaryState: processed.toString(2).padStart(8, '0').slice(-4)
                                });
                            }
                        };
                    `;
                    const blob = new Blob([workerCode], { type: 'application/javascript' });
                    this.worker = new Worker(URL.createObjectURL(blob));
                    this.worker.onmessage = (e) => {
                        if (e.data.type === 'languageDetected') {
                            this.updateQuantumMetrics(e.data.latency, e.data.binaryState);
                        }
                    };
                    console.log('âœ… Quantum Worker initialized');
                } catch (e) {
                    console.warn('âš ï¸ Worker setup failed:', e.message);
                }
            }
            
            // =========================================
            // ×–×™×”×•×™ ×©×¤×” ××”×™×¨
            // =========================================
            detectLanguage(text) {
                const start = performance.now();
                
                // × ×™×¡×™×•×Ÿ 1: ×–×™×”×•×™ ×“×¨×š Unicode ranges
                for (const [range, lang] of Object.entries(this.unicodeLangRanges)) {
                    const regex = new RegExp(`[${range}]`);
                    if (regex.test(text)) {
                        const time = performance.now() - start;
                        this.updateQuantumMetrics(time, '1010');
                        
                        // ×©×œ×™×—×” ×œ-worker ×œ×¢×™×‘×•×“ × ×•×¡×£
                        if (this.worker) {
                            this.worker.postMessage({
                                command: 'detectLanguage',
                                data: text
                            });
                        }
                        
                        return lang;
                    }
                }
                
                // × ×™×¡×™×•×Ÿ 2: ×–×™×”×•×™ ×“×¨×š regex ×¤×©×•×˜
                if (/[×-×ª]/.test(text)) return 'he-IL';
                if (/[Ğ°-ÑĞ-Ğ¯]/.test(text)) return 'ru-RU';
                if (/[\u0900-\u097F]/.test(text)) return 'hi-IN';
                if (/[Ø£-ÙŠ]/.test(text)) return 'ar-SA';
                if (/[à¸-à¹™]/.test(text)) return 'th-TH';
                if (/[áƒ-áƒ°]/.test(text)) return 'ka-GE';
                
                const time = performance.now() - start;
                this.updateQuantumMetrics(time, '0101');
                return 'en-US'; // ×‘×¨×™×¨×ª ××—×“×œ
            }
            
            // =========================================
            // ×¢×“×›×•×Ÿ ××“×“×™×
            // =========================================
            updateQuantumMetrics(latency, binaryState) {
                this.latencyHistory.push(latency);
                if (this.latencyHistory.length > 10) this.latencyHistory.shift();
                
                const avgLatency = this.latencyHistory.reduce((a, b) => a + b, 0) / this.latencyHistory.length;
                
                // ×¢×“×›×•×Ÿ UI
                const latencyEl = document.getElementById('quantumLatency');
                const binaryEl = document.getElementById('quantumBinary');
                
                if (latencyEl) latencyEl.textContent = avgLatency.toFixed(4);
                if (binaryEl) binaryEl.textContent = binaryState || '0101';
            }
            
            // =========================================
            // ×¢×“×›×•×Ÿ ×©×¤×” × ×•×›×—×™×ª
            // =========================================
            updateCurrentLanguage(langCode, confidence) {
                const langKey = langCode.split('-')[0];
                const langData = LANGUAGES_CONFIG[langCode];
                
                if (langData) {
                    // ×¢×“×›×•×Ÿ ××—×•×•×Ÿ ×©×¤×”
                    const indicator = document.getElementById('quantumLangIndicator');
                    const emoji = document.getElementById('quantumLangEmoji');
                    const name = document.getElementById('quantumLangName');
                    const conf = document.getElementById('quantumConfidence');
                    
                    if (indicator) indicator.style.display = 'block';
                    if (emoji) emoji.textContent = langData.emoji;
                    if (name) name.textContent = langData.label;
                    if (conf) conf.textContent = (confidence * 100).toFixed(1);
                    
                    // ×¢×“×›×•×Ÿ ××˜×¨×™×§×¡
                    const currentLang = document.getElementById('quantumCurrentLang');
                    const currentConf = document.getElementById('quantumConf');
                    
                    if (currentLang) currentLang.textContent = langCode;
                    if (currentConf) currentConf.textContent = (confidence * 100).toFixed(1);
                    
                    // ×”×¤×¢×œ×ª ×× ×™××¦×™×”
                    const core = document.getElementById('quantumCore');
                    if (core) {
                        core.classList.add('quantum-active');
                        setTimeout(() => core.classList.remove('quantum-active'), 2000);
                    }
                }
            }
        }
        
        // =========================================
        // QUANTUM VISUALIZER
        // =========================================
        class QuantumVisualizer {
            constructor(canvasId) {
                this.canvas = document.getElementById(canvasId);
                if (!this.canvas) return;
                
                this.ctx = this.canvas.getContext('2d');
                this.canvas.width = window.innerWidth;
                this.canvas.height = window.innerHeight;
                
                this.particles = [];
                this.audioContext = null;
                this.analyser = null;
                this.dataArray = null;
                
                window.addEventListener('resize', () => {
                    this.canvas.width = window.innerWidth;
                    this.canvas.height = window.innerHeight;
                });
            }
            
            // =========================================
            // ××ª×—×•×œ ×¢× ××•×“×™×•
            // =========================================
            initAudio(stream) {
                try {
                    this.audioContext = new (window.AudioContext || window.webkitAudioContext)();
                    this.analyser = this.audioContext.createAnalyser();
                    this.analyser.fftSize = 256;
                    
                    const source = this.audioContext.createMediaStreamSource(stream);
                    source.connect(this.analyser);
                    
                    this.dataArray = new Uint8Array(this.analyser.frequencyBinCount);
                    console.log('âœ… Quantum Visualizer audio initialized');
                } catch (e) {
                    console.warn('âš ï¸ Visualizer audio init failed:', e.message);
                }
            }
            
            // =========================================
            // ×¨×™× ×“×•×¨
            // =========================================
            render() {
                if (!this.ctx) return;
                
                this.ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);
                
                if (this.analyser && this.dataArray) {
                    this.analyser.getByteFrequencyData(this.dataArray);
                    
                    const centerX = this.canvas.width / 2;
                    const centerY = this.canvas.height / 2;
                    const radius = 100;
                    
                    // ×¦×™×•×¨ ×’×œ×™ ×× ×¨×’×™×”
                    for (let i = 0; i < this.dataArray.length; i++) {
                        const value = this.dataArray[i] / 255;
                        const angle = (i / this.dataArray.length) * Math.PI * 2;
                        
                        const x = centerX + Math.cos(angle) * radius * (1 + value);
                        const y = centerY + Math.sin(angle) * radius * (1 + value);
                        
                        this.ctx.beginPath();
                        this.ctx.arc(x, y, 2 * value, 0, Math.PI * 2);
                        this.ctx.fillStyle = `rgba(${value * 255}, ${100 + value * 155}, 255, ${0.3 + value * 0.4})`;
                        this.ctx.fill();
                    }
                }
                
                requestAnimationFrame(() => this.render());
            }
        }
        
        // ×™×¦×™×¨×ª ××•×¤×¢×™× ×’×œ×•×‘×œ×™×™×
        const quantumDetector = new ChaiEmetQuantumLanguageDetector();
        const quantumVisualizer = new QuantumVisualizer('quantumVisualizer');
        quantumVisualizer.render();
        
        
        const SpeechRecognition = window.SpeechRecognition || window.webkitSpeechRecognition;
        let recognition = null;
        let recognitionPool = new Map(); // ğŸ¯ ×‘×¨×™×›×ª ×× ×•×¢×™ ×–×™×”×•×™ - ××—×“ ×œ×›×œ ×©×¤×”!
        let isRecording = false;
        let isWebSpeechActive = false; // ğŸ¤ ×”×× Web Speech API ×¤×¢×™×œ
        let transcriptionHistory = [];
        let uploadedFiles = [];
        let currentVoiceLang = 'he-IL';
        let selectedTranslateLang = '';
        let userId = 'user_' + Math.random().toString(36).substr(2, 9);
        let videoTranscriptHistory = [];
        let currentVideoSubtitles = '';
        let currentVideoTranslations = {};
        let mediaRecorder = null;
        let audioChunks = [];
        let isAudioRecording = false;
        let selectedAudioDevice = '';
        let selectedVideoDevice = '';
        let availableAudioDevices = [];
        let availableVideoDevices = [];
        
        // =========================================
        // ğŸ¤ WEB SPEECH API POOL - ×× ×•×¢ ×œ×›×œ ×©×¤×”!
        // =========================================
        function setupWebSpeechPool() {
            if (!SpeechRecognition) {
                console.warn('âš ï¸ Web Speech API ×œ× × ×ª××š ×‘×“×¤×“×¤×Ÿ');
                return false;
            }
            
            console.log('ğŸ¯ ××›×™×Ÿ Web Speech API Pool...');
            
            // ×™×¦×™×¨×ª ×× ×•×¢ ×œ×›×œ ×©×¤×”
            Object.entries(LANGUAGES_CONFIG).forEach(([langCode, langData]) => {
                try {
                    const rec = new SpeechRecognition();
                    rec.lang = langCode;
                    rec.continuous = true;
                    rec.interimResults = true;
                    rec.maxAlternatives = 3;
                    
                    // ×©××™×¨×” ×‘×‘×¨×™×›×”
                    recognitionPool.set(langCode, rec);
                    console.log(`âœ… Web Speech engine ready: ${langCode}`);
                    
                } catch (e) {
                    console.warn(`âš ï¸ ×œ× ×”×¦×œ×—×ª×™ ×œ×™×¦×•×¨ ×× ×•×¢ ${langCode}: ${e.message}`);
                }
            });
            
            // ×‘×¨×™×¨×ª ××—×“×œ
            recognition = recognitionPool.get('he-IL') || recognitionPool.get('en-US');
            console.log(`âœ… Web Speech Pool ××•×›×Ÿ! ${recognitionPool.size} ×× ×•×¢×™×`);
            return true;
        }
        
        // ğŸš€ ××ª×—×•×œ Web Speech Pool
        const webSpeechReady = setupWebSpeechPool();
        
        // ============ DEVICE ENUMERATION ============
        async function enumerateDevices() {
            try {
                // Try to get permissions first
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ 
                        audio: true, 
                        video: true 
                    });
                    stream.getTracks().forEach(track => track.stop());
                } catch (permError) {
                    console.log('Permission request: ', permError.message);
                }
                
                // Enumerate ALL devices
                const devices = await navigator.mediaDevices.enumerateDevices();
                
                // Filter by type
                availableAudioDevices = devices.filter(device => device.kind === 'audioinput');
                availableVideoDevices = devices.filter(device => device.kind === 'videoinput');
                const audioOutputDevices = devices.filter(device => device.kind === 'audiooutput');
                
                // Update audio device select
                const audioSelect = document.getElementById('audioDeviceSelect');
                if (audioSelect) {
                    audioSelect.innerHTML = '<option value="">ğŸ”„ ×–×”×•×™ ××•×˜×•××˜×™</option>';
                    availableAudioDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        const label = device.label || `××™×§×¨×•×¤×•×Ÿ ${index + 1}`;
                        option.text = `ğŸ™ï¸ ${label}`;
                        audioSelect.appendChild(option);
                    });
                }
                
                // Update video device select
                const videoSelect = document.getElementById('videoDeviceSelect');
                if (videoSelect) {
                    videoSelect.innerHTML = '<option value="">ğŸ”„ ×–×”×•×™ ××•×˜×•××˜×™</option>';
                    availableVideoDevices.forEach((device, index) => {
                        const option = document.createElement('option');
                        option.value = device.deviceId;
                        const label = device.label || `××¦×œ××” ${index + 1}`;
                        option.text = `ğŸ“¹ ${label}`;
                        videoSelect.appendChild(option);
                    });
                }
                
                // Build detailed device list message
                let deviceMsg = 'ğŸ” ×–×™×”×•×™ ×›×¨×˜×™×¡×™ ×§×•×œ:\n\n';
                deviceMsg += `ğŸ™ï¸ **××™×§×¨×•×¤×•× ×™× (${availableAudioDevices.length}):**\n`;
                availableAudioDevices.forEach((device, i) => {
                    const label = device.label || `××™×§×¨×•×¤×•×Ÿ ${i + 1}`;
                    deviceMsg += `  ${i + 1}. ${label}\n`;
                });
                
                deviceMsg += `\nğŸ“¹ **××¦×œ××•×ª (${availableVideoDevices.length}):**\n`;
                availableVideoDevices.forEach((device, i) => {
                    const label = device.label || `××¦×œ××” ${i + 1}`;
                    deviceMsg += `  ${i + 1}. ${label}\n`;
                });
                
                if (audioOutputDevices.length > 0) {
                    deviceMsg += `\nğŸ”Š **×¨××§×•×œ×™× (${audioOutputDevices.length}):**\n`;
                    audioOutputDevices.forEach((device, i) => {
                        const label = device.label || `×¨××§×•×œ ${i + 1}`;
                        deviceMsg += `  ${i + 1}. ${label}\n`;
                    });
                }
                
                const totalDevices = availableAudioDevices.length + availableVideoDevices.length + audioOutputDevices.length;
                if (totalDevices > 0) {
                    addMessage(deviceMsg, false);
                    safeSetText('statusIndicatorVoice', `âœ… ${totalDevices} ×”×ª×§× ×™× ×–×•×”×•`);
                    
                    // Update quantum metrics
                    const metricsEl = document.getElementById('quantumMetrics');
                    if (metricsEl) {
                        metricsEl.innerHTML = `
                            ğŸ™ï¸ Audio: ${availableAudioDevices.length}<br>
                            ğŸ“¹ Video: ${availableVideoDevices.length}<br>
                            ğŸ”Š Output: ${audioOutputDevices.length}<br>
                            âœ… Total: ${totalDevices}
                        `;
                    }
                } else {
                    addMessage(`âš ï¸ ×œ× × ××¦××• ×”×ª×§× ×™× - × × ×ª×Ÿ ×”×¨×©××”`, false);
                }
                
            } catch (error) {
                console.error('Device enumeration error:', error);
                addMessage(`âš ï¸ ×©×’×™××” ×‘×–×™×”×•×™ ×”×ª×§× ×™×: ${error.message}`, false);
                updateStatus('âš ï¸ × ×“×¨×©×•×ª ×”×¨×©××•×ª');
            }
        }
        
        
        function drawVolumeMeter() {
            if (!analyserNode || !isRecordingMobile) return;
            
            const dataArray = new Uint8Array(analyserNode.frequencyBinCount);
            analyserNode.getByteFrequencyData(dataArray);
            
            // Calculate average volume
            let sum = 0;
            for (let i = 0; i < dataArray.length; i++) {
                sum += dataArray[i];
            }
            const average = sum / dataArray.length;
            const volumePercent = (average / 255) * 100;
            
            // Update status with visual indicator
            const bars = Math.round(volumePercent / 10);
            const volumeBar = 'â–ˆ'.repeat(Math.max(1, bars)) + 'â–‘'.repeat(Math.max(0, 10 - bars));
            updateStatus(`ğŸ¤ ${volumeBar} ${Math.round(volumePercent)}%`);
            
            // Continue animation
            animationId = requestAnimationFrame(drawVolumeMeter);
        }
        
        function changeAudioDevice() {
            selectedAudioDevice = document.getElementById('audioDeviceSelect').value;
            const deviceName = availableAudioDevices.find(d => d.deviceId === selectedAudioDevice)?.label || '××•×˜×•××˜×™';
            addMessage(`ğŸ™ï¸ ×‘×—×¨ ×›×¨×˜×™×¡ ×§×•×œ: ${deviceName}`, false);
            
            // Save to localStorage
            localStorage.setItem('hai_emet_audio_device', selectedAudioDevice);
            
            // Close panel on mobile after selection
            if (window.innerWidth <= 768) {
                document.getElementById('voicePanel').classList.remove('open');
            }
        }
        
        function changeVideoDevice() {
            selectedVideoDevice = document.getElementById('videoDeviceSelect').value;
            const deviceName = availableVideoDevices.find(d => d.deviceId === selectedVideoDevice)?.label || '××•×˜×•××˜×™';
            addMessage(`ğŸ“¹ ×‘×—×¨ ×›×¨×˜×™×¡ ×•×™×“××•: ${deviceName}`, false);
            
            // Save to localStorage
            localStorage.setItem('hai_emet_video_device', selectedVideoDevice);
            
            // Close panel on mobile after selection
            if (window.innerWidth <= 768) {
                document.getElementById('voicePanel').classList.remove('open');
            }
        }
        
        // ============ AUDIO OPTIMIZATION ============
        function getOptimizedAudioConstraints() {
            return {
                audio: {
                    deviceId: selectedAudioDevice ? { exact: selectedAudioDevice } : undefined,
                    // High quality settings
                    sampleRate: { ideal: 48000 },
                    sampleSize: { ideal: 16 },
                    channelCount: { ideal: 2 },
                    // Noise suppression
                    noiseSuppression: { ideal: true },
                    echoCancellation: { ideal: true },
                    autoGainControl: { ideal: true },
                    // Advanced audio processing
                    latency: { ideal: 0.01 }
                },
                video: false
            };
        }
        
        // ============ VIDEO OPTIMIZATION ============
        function getOptimizedVideoConstraints() {
            return {
                audio: false,
                video: {
                    deviceId: selectedVideoDevice ? { exact: selectedVideoDevice } : undefined,
                    // High resolution
                    width: { ideal: 1920 },
                    height: { ideal: 1080 },
                    // High frame rate
                    frameRate: { ideal: 60, min: 30 },
                    // Image quality
                    facingMode: 'user',
                    // Advanced settings
                    brightness: { ideal: 100 },
                    contrast: { ideal: 100 },
                    saturation: { ideal: 100 },
                    sharpness: { ideal: 100 },
                    focusMode: { ideal: 'continuous' },
                    focusDistance: { ideal: 0.3 }
                }
            };
        }
        
        // Smart status updater - updates whichever status indicator is visible
        function updateStatus(text) {
            const voiceStatus = document.getElementById('statusIndicatorVoice');
            const textStatus = document.getElementById('statusIndicatorText');
            const fallbackStatus = document.getElementById('statusIndicator');
            
            if (voiceStatus) voiceStatus.textContent = text;
            if (textStatus) textStatus.textContent = text;
            if (fallbackStatus) fallbackStatus.textContent = text;
        }
        
        function safeUpdate(id, value) {
            const el = document.getElementById(id);
            if (el) el.textContent = value;
        }
        
        // Initialize on page load
        window.addEventListener('DOMContentLoaded', () => {
            enumerateDevices();
            
            // Load saved devices from localStorage
            setTimeout(() => {
                const savedAudioDevice = localStorage.getItem('hai_emet_audio_device');
                const savedVideoDevice = localStorage.getItem('hai_emet_video_device');
                
                if (savedAudioDevice) {
                    selectedAudioDevice = savedAudioDevice;
                    const audioSelect = document.getElementById('audioDeviceSelect');
                    if (audioSelect) {
                        audioSelect.value = savedAudioDevice;
                        addMessage(`ğŸ™ï¸ ×˜×¢×•×Ÿ ×”×ª×§×Ÿ ×©××•×¨: ${availableAudioDevices.find(d => d.deviceId === savedAudioDevice)?.label || '×”×ª×§×Ÿ'}`, false);
                    }
                }
                
                if (savedVideoDevice) {
                    selectedVideoDevice = savedVideoDevice;
                    const videoSelect = document.getElementById('videoDeviceSelect');
                    if (videoSelect) {
                        videoSelect.value = savedVideoDevice;
                        addMessage(`ğŸ“¹ ×˜×¢×•×Ÿ ×”×ª×§×Ÿ ×©××•×¨: ${availableVideoDevices.find(d => d.deviceId === savedVideoDevice)?.label || '×”×ª×§×Ÿ'}`, false);
                    }
                }
            }, 1000);
        });
        
        function getPrecisionTime() {
            return (Date.now() / 1000).toFixed(4);
        }
        
        function getExactTime() {
            const now = new Date();
            const hours = String(now.getHours()).padStart(2, '0');
            const minutes = String(now.getMinutes()).padStart(2, '0');
            const seconds = String(now.getSeconds()).padStart(2, '0');
            return `${hours}:${minutes}:${seconds}`;
        }
        
        
        // Switch between voice and text input mode
        function switchMode(mode) {
            const voiceMode = document.getElementById('voiceMode');
            const textMode = document.getElementById('textMode');
            const voiceSection = document.getElementById('voiceRecordingSection');
            const textSection = document.getElementById('textInputSection');
            
            if (mode === 'voice') {
                // Switch to voice mode
                voiceMode.style.background = '#667eea';
                voiceMode.style.color = 'white';
                voiceMode.style.borderColor = 'transparent';
                
                textMode.style.background = 'transparent';
                textMode.style.color = '#667eea';
                textMode.style.borderColor = '#667eea';
                
                voiceSection.style.display = 'block';
                textSection.style.display = 'none';
                
                // Stop recording if in text mode
                if (isRecordingMobile) {
                    mediaRecorderFallback.stop();
                    isRecordingMobile = false;
                }
                
                addMessage('ğŸ¤ ×”×—×œ×™×¤×” ×œ××¦×‘ ×”×§×œ×˜×”', false);
            } else {
                // Switch to text mode
                textMode.style.background = '#667eea';
                textMode.style.color = 'white';
                textMode.style.borderColor = 'transparent';
                
                voiceMode.style.background = 'transparent';
                voiceMode.style.color = '#667eea';
                voiceMode.style.borderColor = '#667eea';
                
                voiceSection.style.display = 'none';
                textSection.style.display = 'block';
                
                // Focus on text input
                setTimeout(() => {
                    const panelInput = document.getElementById('panelTextInput');
                    if (panelInput) panelInput.focus();
                }, 100);
                
                addMessage('âŒ¨ï¸ ×”×—×œ×™×¤×” ×œ××¦×‘ ×”×§×œ×˜', false);
            }
        }
        
        // Send message from panel text input
        async function sendMessageFromPanel() {
            const textInput = document.getElementById('panelTextInput');
            const message = textInput.value.trim();
            
            if (!message) return;
            
            // Add user message to chat
            addMessage(message, true);
            textInput.value = '';
            
            try {
                // Send to server
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'chat',
                        user_id: userId,
                        message: message,
                        language: currentVoiceLang.split('-')[0]
                    })
                });
                
                if (response.ok) {
                    const data = await response.json();
                    const reply = data.response || '×ª×’×•×‘×” ×œ× ×‘×¨×•×¨×”';
                    addMessage(reply, false);
                } else {
                    addMessage('âŒ Error: Server error', false);
                }
            } catch (error) {
                addMessage(`âŒ Error: ${error.message}`, false);
            }
        }
        
        // GLOBAL SAFE UPDATE FUNCTIONS
        window.safeSetText = function(elementId, text) {
            try {
                const el = document.getElementById(elementId);
                if (el) {
                    el.textContent = text;
                    console.log(`âœ… safeSetText: ${elementId} = "${text.substring(0, 50)}..."`);
                    return true;
                } else {
                    console.error(`âŒ safeSetText: Element ${elementId} not found!`);
                }
            } catch (e) {
                console.warn(`âš ï¸ Safe text update failed for ${elementId}: ${e.message}`);
            }
            return false;
        };
        
        window.safeSetHTML = function(elementId, html) {
            try {
                const el = document.getElementById(elementId);
                if (el) {
                    el.innerHTML = html;
                    console.log(`âœ… safeSetHTML: ${elementId}`);
                    return true;
                } else {
                    console.error(`âŒ safeSetHTML: Element ${elementId} not found!`);
                }
            } catch (e) {
                console.warn(`âš ï¸ Safe HTML update failed for ${elementId}: ${e.message}`);
            }
            return false;
        };
        
        // Smart status updater
        function updateStatus(text) {
            try {
                const voiceStatus = document.getElementById('statusIndicatorVoice');
                const textStatus = document.getElementById('statusIndicatorText');
                const fallbackStatus = document.getElementById('statusIndicator');
                
                if (voiceStatus) voiceStatus.textContent = text;
                if (textStatus) textStatus.textContent = text;
                if (fallbackStatus) fallbackStatus.textContent = text;
            } catch (e) {
                console.log('Status update: ' + text);
            }
        }
        
        function togglePanel() {
            const panel = document.getElementById('voicePanel');
            panel.classList.toggle('open');
        }
        
        
        // Upload audio blob received from Web Worker
        async function uploadRecordedAudio(audioBlob, userId) {
            try {
                const formData = new FormData();
                formData.append('audio', audioBlob, 'recording.webm');
                formData.append('language', currentVoiceLang);
                formData.append('user_id', userId);
                formData.append('browser', 'worker');
                
                updateStatus('ğŸ“¤ Uploading from persistent recording...');
                
                const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                    method: 'POST',
                    body: formData
                });
                
                if (response.ok) {
                    const result = await response.json();
                    const transcribedText = result.text || '[××•×“×™×• ×”×•×§×œ×˜ ××š ×œ× × ×™×ª×Ÿ ×œ×”×‘×™×Ÿ]';
                    
                    const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                    const newSavedText = savedText ? savedText + ' ' + transcribedText : transcribedText;
                    safeSetText('finalTranscript', newSavedText);
                    document.getElementById('finalTranscript').setAttribute('data-saved', newSavedText);
                    
                    transcriptionHistory.push({
                        text: transcribedText,
                        time: getExactTime(),
                        lang: currentVoiceLang
                    });
                    
                    addMessage(`ğŸ™ï¸ ×”×ª××œ×•×œ: ${transcribedText}`, false);
                    
                    if (selectedTranslateLang && transcribedText) {
                        translateText(transcribedText, selectedTranslateLang);
                    }
                    
                    updateStatus('âœ… Recording uploaded and transcribed!');
                } else {
                    updateStatus(`âŒ Server error ${response.status}`);
                }
            } catch (error) {
                updateStatus(`âŒ Upload error: ${error.message}`);
            }
        }
        
        function clearTranscription() {
            if (confirm('×‘×˜×•×— ×©×¨×•×¦×” ×œ××—×•×§ ××ª ×›×œ ×”×˜×§×¡×˜?')) {
                safeSetText('finalTranscript', '');
                document.getElementById('finalTranscript').setAttribute('data-saved', '');
                transcriptionHistory = [];
            }
        }
        
        function toggleUploadAccordion(element) {
            const accordion = document.getElementById('uploadAccordion');
            const arrow = element.textContent.includes('â–¶') ? 'â–¼' : 'â–¶';
            element.textContent = element.textContent.replace(/[â–¶â–¼]/, arrow);
            accordion.style.display = accordion.style.display === 'none' ? 'block' : 'none';
        }
        
        function changeVoiceLanguage() {
            const newLang = document.getElementById('voiceLang').value;
            currentVoiceLang = newLang;
            
            // ×¢×“×›×•×Ÿ recognition ××”×‘×¨×™×›×”
            if (recognitionPool.has(newLang)) {
                recognition = recognitionPool.get(newLang);
                console.log(`ğŸŒ ×”×—×œ×¤×ª×™ ×× ×•×¢ ×œ-${newLang}`);
            }
            
            const langName = LANGUAGES_CONFIG[newLang]?.name || 'Unknown';
            updateStatus(`âœ… Language: ${langName}`);
            addMessage(`ğŸŒ ×©×¤×” ×©×•× ×ª×” ×œ-${langName}`, false);
        }
        
        let mediaRecorderFallback = null;
        let audioChunksFallback = [];
        let streamFallback = null;
        let isRecordingMobile = false;

        // Detect browser and device
        function detectBrowser() {
            const ua = navigator.userAgent;
            return {
                isIOS: /iPad|iPhone|iPod/.test(ua),
                isAndroid: /Android/.test(ua),
                isChrome: /Chrome/.test(ua),
                isSafari: /Safari/.test(ua) && !/Chrome/.test(ua),
                isFirefox: /Firefox/.test(ua)
            };
        }

        function toggleRecording() {
            // ğŸ™ï¸ ×©×™××•×© ×™×©×™×¨ ×‘-MediaRecorder - ×¤×©×•×˜ ×•×¢×•×‘×“!
            if (isSimpleRecording && simpleMediaRecorder) {
                // STOP recording
                simpleMediaRecorder.stop();
                isSimpleRecording = false;
                document.getElementById('recordBtn').classList.remove('recording');
                safeSetText('recordBtn', 'ğŸ¤ ×”×§×œ×˜');
                updateStatus('â¹ï¸ ×©×•×œ×— ×œ×©×¨×ª...');
                
                // ğŸ¤ ×¢×¦×™×¨×ª Web Speech API
                if (isWebSpeechActive && recognitionPool.has(currentVoiceLang)) {
                    try {
                        const rec = recognitionPool.get(currentVoiceLang);
                        rec.stop();
                        isWebSpeechActive = false;
                        console.log('ğŸ¤ Web Speech API × ×¢×¦×¨');
                    } catch (e) {
                        console.warn(`âš ï¸ ×©×’×™××” ×‘×¢×¦×™×¨×ª Web Speech: ${e.message}`);
                    }
                }
                
                // Release wake lock
                if (wakeLock) {
                    wakeLock.release().then(() => {
                        wakeLock = null;
                        console.log('ğŸ”“ Wake Lock released');
                    });
                }
                
                return;
            }
            
            // START recording
            navigator.mediaDevices.getUserMedia(getOptimizedAudioConstraints())
                .then(async stream => {
                    simpleStream = stream;
                    simpleAudioChunks = [];
                    
                    // ğŸ¨ ××ª×—×•×œ Quantum Visualizer
                    try {
                        quantumVisualizer.initAudio(stream);
                    } catch (e) {
                        console.log('Visualizer init skipped:', e.message);
                    }
                    
                    // Request Wake Lock - keeps recording even when tab is inactive
                    try {
                        if ('wakeLock' in navigator) {
                            wakeLock = await navigator.wakeLock.request('screen');
                            console.log('ğŸ”’ Wake Lock acquired - recording will continue');
                            addMessage('ğŸ”’ ×”×§×œ×˜×” ××•×’× ×ª - ×ª××©×™×š ×’× ×× ×ª×¢×‘×•×¨ ×œ×œ×©×•× ×™×ª ××—×¨×ª', false);
                        }
                    } catch (err) {
                        console.log('Wake Lock not supported or denied');
                    }
                    
                    // Choose best mime type
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/mp4';
                    }
                    
                    simpleMediaRecorder = new MediaRecorder(stream, { mimeType });
                    
                    simpleMediaRecorder.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            simpleAudioChunks.push(e.data);
                        }
                    };
                    
                    simpleMediaRecorder.onstop = async () => {
                        const audioBlob = new Blob(simpleAudioChunks, { type: simpleMediaRecorder.mimeType });
                        
                        // Upload to server
                        const formData = new FormData();
                        formData.append('audio', audioBlob, 'recording.webm');
                        formData.append('language', currentVoiceLang);
                        formData.append('user_id', userId);
                        formData.append('browser', 'simple');
                        
                        try {
                            updateStatus('ğŸ“¤ ××¢×œ×” ×œ×©×¨×ª...');
                            
                            const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const result = await response.json();
                                const transcribedText = result.text || '[×”×§×œ×˜×” ×”×ª×§×‘×œ×”]';
                                
                                // ğŸ§¬ Quantum Language Detection
                                const detectedLang = quantumDetector.detectLanguage(transcribedText);
                                const confidence = result.confidence || 0.85;
                                quantumDetector.updateCurrentLanguage(detectedLang, confidence);
                                console.log(`ğŸ§¬ Quantum detected: ${detectedLang} (${(confidence * 100).toFixed(1)}%)`);
                                
                                const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                                const newSavedText = savedText ? savedText + ' ' + transcribedText : transcribedText;
                                safeSetText('finalTranscript', newSavedText);
                                document.getElementById('finalTranscript').setAttribute('data-saved', newSavedText);
                                
                                transcriptionHistory.push({
                                    text: transcribedText,
                                    time: getExactTime(),
                                    lang: currentVoiceLang
                                });
                                
                                addMessage(`ğŸ™ï¸ ${transcribedText}`, false);
                                
                                if (selectedTranslateLang && transcribedText) {
                                    translateText(transcribedText, selectedTranslateLang);
                                }
                                
                                updateStatus('âœ… ×”×§×œ×˜×” ×”×¦×œ×™×—×”!');
                            } else {
                                updateStatus(`âŒ ×©×’×™××” ${response.status}`);
                            }
                        } catch (error) {
                            updateStatus(`âŒ ×©×’×™××”: ${error.message}`);
                        } finally {
                            if (simpleStream) {
                                simpleStream.getTracks().forEach(track => track.stop());
                            }
                        }
                    };
                    
                    simpleMediaRecorder.start();
                    isSimpleRecording = true;
                    document.getElementById('recordBtn').classList.add('recording');
                    safeSetText('recordBtn', 'â¹ï¸ ×¢×¦×•×¨');
                    updateStatus('ğŸ§ ××§×œ×™×˜... ×“×‘×¨ ×¢×›×©×™×•!');
                    addMessage('ğŸ™ï¸ ×”×§×œ×˜×” ×”×ª×—×™×œ×” - ×××©×™×›×” ×’× ×‘×œ×©×•× ×™×•×ª ××—×¨×•×ª', false);
                    
                    // ğŸ¤ ×”×¤×¢×œ×ª Web Speech API ×œ×ª××œ×•×œ ×‘×–××Ÿ ×××ª!
                    if (webSpeechReady && recognitionPool.has(currentVoiceLang)) {
                        const rec = recognitionPool.get(currentVoiceLang);
                        
                        rec.onresult = (event) => {
                            const last = event.results.length - 1;
                            const transcript = event.results[last][0].transcript;
                            const confidence = event.results[last][0].confidence || 0.85;
                            
                            // ×¢×“×›×•×Ÿ UI ×‘×–××Ÿ ×××ª
                            const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                            const displayText = savedText ? savedText + ' ' + transcript : transcript;
                            safeSetText('finalTranscript', displayText);
                            
                            // ×× ×¡×•×¤×™ - ×©××™×¨×”
                            if (event.results[last].isFinal) {
                                document.getElementById('finalTranscript').setAttribute('data-saved', displayText);
                                
                                // Quantum Language Detection
                                const detectedLang = quantumDetector.detectLanguage(transcript);
                                quantumDetector.updateCurrentLanguage(detectedLang, confidence);
                                
                                // ×”×•×¡×¤×” ×œ×”×™×¡×˜×•×¨×™×”
                                transcriptionHistory.push({
                                    text: transcript,
                                    time: getExactTime(),
                                    lang: currentVoiceLang,
                                    source: 'web-speech'
                                });
                                
                                // ×ª×¨×’×•× ×× × ×‘×—×¨
                                if (selectedTranslateLang) {
                                    translateText(transcript, selectedTranslateLang);
                                }
                            }
                        };
                        
                        rec.onerror = (event) => {
                            console.warn(`âš ï¸ Web Speech error: ${event.error}`);
                        };
                        
                        rec.onend = () => {
                            isWebSpeechActive = false;
                            console.log('ğŸ¤ Web Speech stopped');
                        };
                        
                        try {
                            rec.start();
                            isWebSpeechActive = true;
                            console.log('ğŸ¤ Web Speech API ×”×ª×—×™×œ!');
                            addMessage('ğŸ¤ ×ª××œ×•×œ ×‘×–××Ÿ ×××ª ×¤×¢×™×œ!', false);
                        } catch (e) {
                            console.warn(`âš ï¸ ×œ× ×”×¦×œ×—×ª×™ ×œ×”×¤×¢×™×œ Web Speech: ${e.message}`);
                        }
                    }
                })
                .catch(error => {
                    updateStatus('âŒ ×©×’×™××” ×‘×”×¨×©××•×ª');
                    addMessage(`âš ï¸ ${error.message}`, false);
                });
        }
        
        // ========================================
        // ğŸ”´ LIVE STREAMING FUNCTION
        // ========================================
        let isLiveStreaming = false;
        let liveStreamRecorder = null;
        let liveStreamChunks = [];
        let liveStreamInterval = null;
        
        async function toggleLiveStream() {
            if (isLiveStreaming && liveStreamRecorder) {
                // STOP live streaming
                isLiveStreaming = false;
                
                if (liveStreamRecorder && liveStreamRecorder.state !== 'inactive') {
                    liveStreamRecorder.stop();
                }
                
                if (liveStreamInterval) {
                    clearInterval(liveStreamInterval);
                    liveStreamInterval = null;
                }
                
                // ğŸ¤ ×¢×¦×™×¨×ª Web Speech API
                if (isWebSpeechActive && recognitionPool.has(currentVoiceLang)) {
                    try {
                        const rec = recognitionPool.get(currentVoiceLang);
                        rec.stop();
                        isWebSpeechActive = false;
                        console.log('ğŸ”´ Live Web Speech API × ×¢×¦×¨');
                    } catch (e) {
                        console.warn(`âš ï¸ ×©×’×™××” ×‘×¢×¦×™×¨×ª Live Web Speech: ${e.message}`);
                    }
                }
                
                document.getElementById('liveStreamBtn').classList.remove('recording');
                safeSetText('liveStreamBtn', 'ğŸ”´ ×©×™×“×•×¨ ×—×™');
                updateStatus('â¹ï¸ ×©×™×“×•×¨ ×”×•×¤×¡×§');
                addMessage('â¹ï¸ ×©×™×“×•×¨ ×—×™ ×”×•×¤×¡×§', false);
                
                // Update quantum metrics
                const metricsEl = document.getElementById('quantumMetrics');
                if (metricsEl) {
                    metricsEl.innerHTML = metricsEl.innerHTML.replace('ğŸ”´ LIVE', 'â¹ï¸ STOPPED');
                }
                
                return;
            }
            
            // START live streaming
            try {
                const stream = await navigator.mediaDevices.getUserMedia(getOptimizedAudioConstraints());
                
                // Initialize quantum visualizer
                try {
                    quantumVisualizer.initAudio(stream);
                } catch (e) {
                    console.log('Visualizer init skipped:', e.message);
                }
                
                // Choose best mime type
                let mimeType = 'audio/webm;codecs=opus';
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/webm';
                }
                if (!MediaRecorder.isTypeSupported(mimeType)) {
                    mimeType = 'audio/mp4';
                }
                
                liveStreamRecorder = new MediaRecorder(stream, { mimeType });
                liveStreamChunks = [];
                let chunkCount = 0;
                
                // Collect chunks
                liveStreamRecorder.ondataavailable = async (e) => {
                    if (e.data.size > 0) {
                        liveStreamChunks.push(e.data);
                        chunkCount++;
                        
                        // Send chunk to server immediately
                        const audioBlob = new Blob([e.data], { type: mimeType });
                        const formData = new FormData();
                        formData.append('audio', audioBlob, `live_chunk_${Date.now()}.webm`);
                        formData.append('language', currentVoiceLang);
                        formData.append('user_id', userId);
                        formData.append('live_stream', 'true');
                        formData.append('chunk_number', chunkCount);
                        
                        try {
                            updateStatus(`ğŸ”´ ×©×™×“×•×¨ ×—×™... [${chunkCount} chunks]`);
                            
                            const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                                method: 'POST',
                                body: formData
                            });
                            
                            if (response.ok) {
                                const result = await response.json();
                                const transcribedText = result.text || result.transcription || '';
                                
                                if (transcribedText.trim()) {
                                    // ğŸ§¬ Quantum Language Detection
                                    const detectedLang = quantumDetector.detectLanguage(transcribedText);
                                    const confidence = result.confidence || 0.85;
                                    quantumDetector.updateCurrentLanguage(detectedLang, confidence);
                                    
                                    // Update transcript in real-time
                                    const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                                    const newText = savedText ? savedText + ' ' + transcribedText : transcribedText;
                                    safeSetText('finalTranscript', newText);
                                    document.getElementById('finalTranscript').setAttribute('data-saved', newText);
                                    
                                    // Show in chat
                                    addMessage(`ğŸ”´ [×©×™×“×•×¨ ×—×™] ${transcribedText}`, false);
                                    
                                    // ğŸŒ Real-time translation for live stream
                                    if (selectedTranslateLang && transcribedText.trim()) {
                                        translateText(transcribedText, selectedTranslateLang);
                                    }
                                    
                                    // Update quantum metrics
                                    const metricsEl = document.getElementById('quantumMetrics');
                                    if (metricsEl) {
                                        metricsEl.innerHTML = `
                                            ğŸ”´ LIVE<br>
                                            ğŸ“¦ Chunks: ${chunkCount}<br>
                                            ğŸŒ ${detectedLang}<br>
                                            ğŸ¯ ${(confidence * 100).toFixed(0)}%
                                        `;
                                    }
                                }
                            }
                        } catch (error) {
                            console.error('Live stream chunk error:', error);
                        }
                    }
                };
                
                // Start recording with 3-second chunks
                liveStreamRecorder.start(3000);
                isLiveStreaming = true;
                
                document.getElementById('liveStreamBtn').classList.add('recording');
                safeSetText('liveStreamBtn', 'â¹ï¸ ×¢×¦×•×¨ ×©×™×“×•×¨');
                updateStatus('ğŸ”´ ×©×™×“×•×¨ ×—×™ ×¤×¢×™×œ!');
                addMessage('ğŸ”´ ×©×™×“×•×¨ ×—×™ ×”×ª×—×™×œ - ×ª××œ×•×œ ×‘×–××Ÿ ×××ª ×›×œ 3 ×©× ×™×•×ª', false);
                
                // ğŸ¤ ×”×¤×¢×œ×ª Web Speech API ×œ×©×™×“×•×¨ ×—×™!
                if (webSpeechReady && recognitionPool.has(currentVoiceLang)) {
                    const rec = recognitionPool.get(currentVoiceLang);
                    
                    rec.onresult = (event) => {
                        const last = event.results.length - 1;
                        const transcript = event.results[last][0].transcript;
                        const confidence = event.results[last][0].confidence || 0.85;
                        
                        // ×¢×“×›×•×Ÿ UI ×‘×–××Ÿ ×××ª
                        const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                        const displayText = savedText ? savedText + ' ' + transcript : transcript;
                        safeSetText('finalTranscript', displayText);
                        
                        // ×× ×¡×•×¤×™ - ×©××™×¨×” ×•×”×¦×’×”
                        if (event.results[last].isFinal) {
                            document.getElementById('finalTranscript').setAttribute('data-saved', displayText);
                            
                            // ×”×¦×’×” ×‘×¦'××˜
                            addMessage(`ğŸ”´ [Live] ${transcript}`, false);
                            
                            // Quantum Language Detection
                            const detectedLang = quantumDetector.detectLanguage(transcript);
                            quantumDetector.updateCurrentLanguage(detectedLang, confidence);
                            
                            // ×ª×¨×’×•× ×‘×–××Ÿ ×××ª
                            if (selectedTranslateLang && transcript.trim()) {
                                translateText(transcript, selectedTranslateLang);
                            }
                            
                            // ×”×•×¡×¤×” ×œ×”×™×¡×˜×•×¨×™×”
                            transcriptionHistory.push({
                                text: transcript,
                                time: getExactTime(),
                                lang: currentVoiceLang,
                                source: 'live-web-speech'
                            });
                        }
                    };
                    
                    rec.onerror = (event) => {
                        console.warn(`âš ï¸ Live Web Speech error: ${event.error}`);
                    };
                    
                    rec.onend = () => {
                        isWebSpeechActive = false;
                        console.log('ğŸ¤ Live Web Speech stopped');
                    };
                    
                    try {
                        rec.start();
                        isWebSpeechActive = true;
                        console.log('ğŸ”´ Live Web Speech API ×”×ª×—×™×œ!');
                        addMessage('ğŸ¤ ×ª××œ×•×œ ×—×™ ×™×©×™×¨ ×¤×¢×™×œ!', false);
                    } catch (e) {
                        console.warn(`âš ï¸ ×œ× ×”×¦×œ×—×ª×™ ×œ×”×¤×¢×™×œ Live Web Speech: ${e.message}`);
                    }
                }
                
                // Update quantum metrics
                const metricsEl = document.getElementById('quantumMetrics');
                if (metricsEl) {
                    metricsEl.innerHTML = `
                        ğŸ”´ LIVE<br>
                        ğŸ“¦ Chunks: 0<br>
                        ğŸŒ Streaming...<br>
                        ğŸ¯ Ready
                    `;
                }
                
            } catch (error) {
                updateStatus('âŒ ×©×’×™××” ×‘×”×¨×©××•×ª');
                addMessage(`âš ï¸ ×©×™×“×•×¨ ×—×™ × ×›×©×œ: ${error.message}`, false);
                console.error('Live stream error:', error);
            }
        }
        
        let audioContextFallback = null;
        let analyserNode = null;
        let animationId = null;

        async function toggleAudioRecordingFallback() {
            const browser = detectBrowser();
            
            if (isRecordingMobile && mediaRecorderFallback) {
                // Stop recording
                mediaRecorderFallback.stop();
                isRecordingMobile = false;
                document.getElementById('recordBtn').classList.remove('recording');
                updateStatus('â¹ï¸ Sending to server...');
                
                // Stop volume meter animation
                if (animationId) {
                    cancelAnimationFrame(animationId);
                }
            } else {
                // Start recording
                try {
                    // Request permission with proper constraints
                    const constraints = {
                        audio: {
                            echoCancellation: true,
                            noiseSuppression: true,
                            autoGainControl: false,  // Disable for better control
                            sampleRate: { ideal: 48000 }
                        }
                    };
                    
                    streamFallback = await navigator.mediaDevices.getUserMedia(constraints);
                    audioChunksFallback = [];
                    
                    // Create audio context for volume meter
                    if (!audioContextFallback) {
                        audioContextFallback = new (window.AudioContext || window.webkitAudioContext)();
                    }
                    
                    const sourceNode = audioContextFallback.createMediaStreamSource(streamFallback);
                    analyserNode = audioContextFallback.createAnalyser();
                    analyserNode.fftSize = 2048;
                    sourceNode.connect(analyserNode);
                    
                    // Start volume meter animation
                    drawVolumeMeter();
                    
                    // Choose mime type based on browser support
                    let mimeType = 'audio/webm;codecs=opus';
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/webm';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/mp4';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = 'audio/wav';
                    }
                    if (!MediaRecorder.isTypeSupported(mimeType)) {
                        mimeType = ''; // Browser will choose
                    }
                    
                    const options = mimeType ? { mimeType: mimeType } : {};
                    mediaRecorderFallback = new MediaRecorder(streamFallback, options);
                    
                    mediaRecorderFallback.ondataavailable = (e) => {
                        if (e.data.size > 0) {
                            audioChunksFallback.push(e.data);
                        }
                    };
                    
                    mediaRecorderFallback.onstop = async () => {
                        try {
                            // Create audio blob
                            const audioBlob = new Blob(audioChunksFallback, { type: mediaRecorderFallback.mimeType || 'audio/webm' });
                            const blobSize = audioBlob.size;
                            
                            logger(`ğŸ“Š Audio blob created: ${blobSize} bytes`);
                            
                            if (blobSize === 0) {
                                addMessage('âš ï¸ Warning: No audio data recorded', false);
                                return;
                            }
                            
                            // Create FormData
                            const formData = new FormData();
                            formData.append('audio', audioBlob, `recording.${browser.isIOS ? 'wav' : 'webm'}`);
                            formData.append('language', currentVoiceLang);
                            formData.append('user_id', userId);
                            formData.append('browser', browser.isSafari ? 'safari' : browser.isIOS ? 'ios' : browser.isAndroid ? 'android' : 'other');
                            
                            addMessage(`ğŸ“¤ Uploading ${Math.round(blobSize / 1024)}KB...`, false);
                            updateStatus(`ğŸ“¤ Uploading ${Math.round(blobSize / 1024)}KB...`);
                            
                            // Send to server with timeout
                            const controller = new AbortController();
                            const timeoutId = setTimeout(() => controller.abort(), 30000); // 30s timeout
                            
                            const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                                method: 'POST',
                                body: formData,
                                signal: controller.signal
                            });
                            
                            clearTimeout(timeoutId);
                            
                            logger(`âœ… Server response: ${response.status}`);
                            
                            if (response.ok) {
                                const result = await response.json();
                                const transcribedText = result.text || '[××•×“×™×• ×”×•×§×œ×˜ ××š ×œ× × ×™×ª×Ÿ ×œ×”×‘×™×Ÿ]';
                                
                                const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                                const newSavedText = savedText ? savedText + ' ' + transcribedText : transcribedText;
                                safeSetText('finalTranscript', newSavedText);
                                document.getElementById('finalTranscript').setAttribute('data-saved', newSavedText);
                                
                                transcriptionHistory.push({
                                    text: transcribedText,
                                    time: getExactTime(),
                                    lang: currentVoiceLang
                                });
                                
                                addMessage(`ğŸ™ï¸ ×”×ª××œ×•×œ: ${transcribedText}`, false);
                                
                                if (selectedTranslateLang && transcribedText) {
                                    translateText(transcribedText, selectedTranslateLang);
                                }
                                
                                updateStatus('âœ… Ready');
                            } else {
                                const errorText = await response.text();
                                updateStatus(`âŒ Server error ${response.status}`);
                                addMessage(`âŒ ×©×’×™××”: ${response.status} - ${errorText.substring(0, 100)}`, false);
                            }
                        } catch (error) {
                            updateStatus('âŒ Upload failed');
                            if (error.name === 'AbortError') {
                                addMessage('âŒ Upload timeout - check connection', false);
                            } else {
                                addMessage(`âŒ Error: ${error.message}`, false);
                            }
                        } finally {
                            // Stop stream
                            if (streamFallback) {
                                streamFallback.getTracks().forEach(track => track.stop());
                            }
                        }
                    };
                    
                    mediaRecorderFallback.start();
                    isRecordingMobile = true;
                    document.getElementById('recordBtn').classList.add('recording');
                    updateStatus('ğŸ§ ×”×§×œ×˜×”... ×“×‘×¨ ×‘×¢×‘×¨×™×ª!');
                    addMessage(`ğŸ™ï¸ ×”×§×œ×˜×” ×”×ª×—×™×œ×” (${browser.isIOS ? 'iOS' : 'Android'}${browser.isChrome ? ' Chrome' : browser.isSafari ? ' Safari' : ''})`, false);
                    
                } catch (error) {
                    updateStatus('âŒ Microphone denied');
                    let errorMsg = error.message;
                    if (error.name === 'NotAllowedError') {
                        errorMsg = '×”×Ÿ ×”×¨×©××” ×œ××™×§×¨×•×¤×•×Ÿ ×‘×”×’×“×¨×•×ª';
                    } else if (error.name === 'NotFoundError') {
                        errorMsg = '××™×Ÿ ××™×§×¨×•×¤×•×Ÿ ×–××™×Ÿ';
                    }
                    addMessage(`âš ï¸ ${errorMsg}`, false);
                }
            }
        }
        
        async function translateText(text, targetLang) {
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${getLangCode(currentVoiceLang)}|${targetLang}`);
                const data = await response.json();
                
                if (data.responseStatus === 200) {
                    safeSetText('translatedText', data.responseData.translatedText);
                }
            } catch (e) {
                console.log('Translation unavailable');
            }
        }
        
        function getLangCode(fullLang) {
            const codes = {
                'he-IL': 'he', 'en-US': 'en', 'es-ES': 'es', 'fr-FR': 'fr',
                'de-DE': 'de', 'it-IT': 'it', 'pt-PT': 'pt', 'ru-RU': 'ru',
                'ar-SA': 'ar', 'ja-JP': 'ja', 'zh-CN': 'zh', 'ko-KR': 'ko',
                'hi-IN': 'hi', 'nl-NL': 'nl', 'pl-PL': 'pl'
            };
            return codes[fullLang] || 'en';
        }
        
        function changeTranslateLanguage() {
            selectedTranslateLang = document.getElementById('translateLang').value;
            const translatedBox = document.getElementById('translatedBox');
            
            if (selectedTranslateLang) {
                translatedBox.style.display = 'block';
                const currentText = document.getElementById('finalTranscript').textContent.trim();
                if (currentText) {
                    translateText(currentText, selectedTranslateLang);
                }
            } else {
                translatedBox.style.display = 'none';
                safeSetText('translatedText', '');
            }
        }
        
        
        function logger(msg) {
            console.log(`[Hai-Emet] ${msg}`);
        }
        
        function addMessage(text, isUser = false) {
            const messageEl = document.createElement('div');
            messageEl.className = `message ${isUser ? 'user' : 'assistant'}`;
            
            const wrapper = document.createElement('div');
            wrapper.className = 'message-wrapper';
            
            const contentEl = document.createElement('div');
            contentEl.className = 'message-content';
            contentEl.textContent = text;
            
            const timeEl = document.createElement('div');
            timeEl.className = 'message-time';
            timeEl.textContent = getExactTime();
            
            wrapper.appendChild(contentEl);
            wrapper.appendChild(timeEl);
            messageEl.appendChild(wrapper);
            document.getElementById('chatArea').appendChild(messageEl);
            
            document.getElementById('chatArea').scrollTop = document.getElementById('chatArea').scrollHeight;
        }
        
        async function sendMessage() {
            const message = document.getElementById('messageInput').value.trim();
            if (!message) return;
            
            addMessage(message, true);
            const msgInput = document.getElementById('messageInput');
            if (msgInput) msgInput.value = '';
            updateStatus('â³ ××©×“×¨×ª ×ª×’×•×‘×”...');
            
            try {
                const response = await fetch(API_URL, {
                    method: 'POST',
                    headers: { 'Content-Type': 'application/json' },
                    body: JSON.stringify({
                        action: 'chat',
                        message: message,
                        token: TOKEN,
                        language: currentVoiceLang,
                        userId: userId,
                        timestamp: getPrecisionTime()
                    })
                });
                
                const data = await response.json();
                
                if (data.reply) {
                    addMessage(data.reply, false);
                }
                
                updateStatus('âœ… ×‘×—×–×¨×” ××”×œ×™×‘×”');
                
                transcriptionHistory.push({
                    text: message,
                    reply: data.reply,
                    time: getPrecisionTime(),
                    lang: currentVoiceLang,
                    learned: data.learned
                });
                
            } catch (error) {
                addMessage('âŒ ×©×’×™××” ×‘×—×™×‘×•×¨ ×œ×œ×™×‘×”.', false);
                updateStatus('âŒ ×©×’×™××”');
            }
        }
        
        function saveTranscriptionTXT() {
            if (transcriptionHistory.length === 0) {
                alert('××™×Ÿ ×˜×§×¡×˜ ×œ×©××•×¨');
                return;
            }
            
            const content = transcriptionHistory.map((t, i) => 
                `${i + 1}. [${t.time}s] ${t.text}`
            ).join('\n');
            
            const header = `×—×™-×××ª Transcription\n`;
            const metadata = `×©×¤×”: ${LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown'}\n×–××Ÿ: ${new Date().toLocaleString('he-IL')}\n${'='.repeat(50)}\n`;
            const fullContent = header + metadata + content;
            
            const blob = new Blob([fullContent], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            const filename = `transcription_${Date.now()}.txt`;
            link.download = filename;
            link.click();
            
            uploadedFiles.push({
                name: filename,
                time: getPrecisionTime(),
                type: 'txt',
                size: (blob.size / 1024).toFixed(2) + ' KB'
            });
            updateFilesList();
            addMessage(`ğŸ“„ ×©××•×¨: ${filename}`, false);
        }
        
        function saveTranscriptionDOCX() {
            if (transcriptionHistory.length === 0) {
                alert('××™×Ÿ ×˜×§×¡×˜ ×œ×©××•×¨');
                return;
            }
            
            // ğŸ“ Create rich formatted sections
            const sections = transcriptionHistory.map((t, i) => {
                const isEven = i % 2 === 0;
                return new docx.Paragraph({
                    children: [
                        new docx.TextRun({
                            text: `${i + 1}. `,
                            bold: true,
                            color: "667eea",
                            size: 24
                        }),
                        new docx.TextRun({
                            text: `[${t.time}] `,
                            italics: true,
                            color: "999999",
                            size: 20
                        }),
                        new docx.TextRun({
                            text: t.text,
                            size: 22,
                            font: "Arial"
                        })
                    ],
                    spacing: { 
                        line: 360,
                        before: 120,
                        after: 120
                    },
                    shading: {
                        fill: isEven ? "f8f9fa" : "ffffff",
                        type: docx.ShadingType.CLEAR
                    },
                    border: {
                        bottom: {
                            color: "e0e0e0",
                            space: 1,
                            style: docx.BorderStyle.SINGLE,
                            size: 6
                        }
                    }
                });
            });
            
            // ğŸ“Š Create document with rich formatting
            const doc = new docx.Document({
                sections: [{
                    properties: {
                        page: {
                            margin: {
                                top: 1440,
                                right: 1440,
                                bottom: 1440,
                                left: 1440
                            }
                        }
                    },
                    children: [
                        // ğŸ’› Main Title
                        new docx.Paragraph({
                            children: [
                                new docx.TextRun({
                                    text: "ğŸ’› ×—×™-×××ª",
                                    bold: true,
                                    size: 48,
                                    color: "ffd700"
                                }),
                                new docx.TextRun({
                                    text: " - ×ª××œ×•×œ ×§×•×œ×™",
                                    bold: true,
                                    size: 36,
                                    color: "667eea"
                                })
                            ],
                            heading: docx.HeadingLevel.HEADING_1,
                            spacing: { after: 400 },
                            alignment: docx.AlignmentType.CENTER,
                            border: {
                                bottom: {
                                    color: "667eea",
                                    space: 1,
                                    style: docx.BorderStyle.DOUBLE,
                                    size: 24
                                }
                            }
                        }),
                        
                        // ğŸ“‹ Metadata Table
                        new docx.Table({
                            width: {
                                size: 100,
                                type: docx.WidthType.PERCENTAGE
                            },
                            borders: {
                                top: { style: docx.BorderStyle.SINGLE, size: 1, color: "667eea" },
                                bottom: { style: docx.BorderStyle.SINGLE, size: 1, color: "667eea" },
                                left: { style: docx.BorderStyle.SINGLE, size: 1, color: "667eea" },
                                right: { style: docx.BorderStyle.SINGLE, size: 1, color: "667eea" }
                            },
                            rows: [
                                new docx.TableRow({
                                    children: [
                                        new docx.TableCell({
                                            children: [new docx.Paragraph({ text: "ğŸŒ ×©×¤×”:", bold: true })],
                                            shading: { fill: "667eea", color: "ffffff" }
                                        }),
                                        new docx.TableCell({
                                            children: [new docx.Paragraph(LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown')]
                                        })
                                    ]
                                }),
                                new docx.TableRow({
                                    children: [
                                        new docx.TableCell({
                                            children: [new docx.Paragraph({ text: "ğŸ• ×–××Ÿ:", bold: true })],
                                            shading: { fill: "667eea", color: "ffffff" }
                                        }),
                                        new docx.TableCell({
                                            children: [new docx.Paragraph(new Date().toLocaleString('he-IL'))]
                                        })
                                    ]
                                }),
                                new docx.TableRow({
                                    children: [
                                        new docx.TableCell({
                                            children: [new docx.Paragraph({ text: "ğŸ“ ××©×¤×˜×™×:", bold: true })],
                                            shading: { fill: "667eea", color: "ffffff" }
                                        }),
                                        new docx.TableCell({
                                            children: [new docx.Paragraph(transcriptionHistory.length.toString())]
                                        })
                                    ]
                                })
                            ]
                        }),
                        
                        new docx.Paragraph({ text: "", spacing: { after: 400 } }),
                        
                        // ğŸ“„ Transcription Header
                        new docx.Paragraph({
                            children: [
                                new docx.TextRun({
                                    text: "ğŸ“„ ×ª××œ×•×œ ××œ×",
                                    bold: true,
                                    size: 32,
                                    color: "667eea"
                                })
                            ],
                            heading: docx.HeadingLevel.HEADING_2,
                            spacing: { after: 300 }
                        }),
                        
                        // ğŸ’¬ Transcription content
                        ...sections,
                        
                        // ğŸ”’ Footer
                        new docx.Paragraph({ text: "", spacing: { before: 400 } }),
                        new docx.Paragraph({
                            children: [
                                new docx.TextRun({
                                    text: "â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•",
                                    color: "999999"
                                })
                            ],
                            alignment: docx.AlignmentType.CENTER
                        }),
                        new docx.Paragraph({
                            children: [
                                new docx.TextRun({
                                    text: "ğŸ”’ TNTF | Binary: 0101-0101(0101) | ×—×™-×××ª ğŸ’›",
                                    italics: true,
                                    size: 18,
                                    color: "667eea"
                                })
                            ],
                            alignment: docx.AlignmentType.CENTER,
                            spacing: { before: 200 }
                        })
                    ]
                }]
            });
            
            docx.Packer.toBlob(doc).then(blob => {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                const filename = `×—×™-×××ª_×ª××œ×•×œ_${Date.now()}.docx`;
                link.download = filename;
                link.click();
                
                uploadedFiles.push({
                    name: filename,
                    time: getPrecisionTime(),
                    type: 'docx',
                    size: (blob.size / 1024).toFixed(2) + ' KB'
                });
                updateFilesList();
                addMessage(`ğŸ“‹ ×©××•×¨: ${filename}`, false);
            });
        }
        
        async function handleAudioUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const timestamp = Date.now();
            const fileData = {
                name: file.name,
                time: getPrecisionTime(),
                type: 'audio',
                size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                transcription: 'â³ ××¢×‘×“ ××•×“×™×•...',
                id: timestamp
            };
            
            uploadedFiles.push(fileData);
            updateFilesList();
            addMessage(`ğŸµ ××¢×œ×”: ${file.name}...`, false);
            
            // Create audio player with download buttons
            const audioURL = URL.createObjectURL(file);
            const audioPlayerHTML = `
                <div id="audioPlayer_${timestamp}" style="background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 15px; border-radius: 12px; margin: 12px 0; box-shadow: 0 4px 15px rgba(102, 126, 234, 0.3);">
                    <div style="font-weight: bold; margin-bottom: 10px; color: white; font-size: 1.1em;">ğŸµ ${file.name}</div>
                    <audio controls style="width: 100%; margin-bottom: 12px; border-radius: 8px;" id="audio_${timestamp}">
                        <source src="${audioURL}" type="${file.type}">
                    </audio>
                    
                    <div style="background: rgba(255,255,255,0.2); height: 6px; border-radius: 3px; overflow: hidden; margin-bottom: 10px;">
                        <div id="audioProgress_${timestamp}" style="background: #FFD700; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    
                    <div style="font-size: 0.9em; color: white; margin-bottom: 12px; font-weight: 600;" id="audioStatus_${timestamp}">
                        â³ ××¢×‘×“ ×ª××œ×•×œ... 0%
                    </div>
                    
                    <div id="transcriptionText_${timestamp}" style="background: rgba(0,0,0,0.3); padding: 12px; border-radius: 8px; color: white; min-height: 60px; margin-bottom: 12px; display: none; line-height: 1.8; direction: rtl; text-align: right;">
                        <div style="font-weight: bold; margin-bottom: 6px; color: #FFD700;">ğŸ“ ×ª××œ×•×œ:</div>
                        <div id="transcriptionContent_${timestamp}"></div>
                    </div>
                    
                    <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 8px;">
                        <button onclick="downloadAudioTranscription(${timestamp}, 'txt')" style="background: #28a745; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            ğŸ“„ ×”×•×¨×“ TXT
                        </button>
                        <button onclick="downloadAudioTranscription(${timestamp}, 'docx')" style="background: #17a2b8; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer; font-weight: bold;">
                            ğŸ“‹ ×”×•×¨×“ DOCX
                        </button>
                    </div>
                </div>
            `;
            
            const transcriptionBox = document.querySelector('.transcription-box');
            if (transcriptionBox && transcriptionBox.parentNode) {
                const playerDiv = document.createElement('div');
                playerDiv.innerHTML = audioPlayerHTML;
                transcriptionBox.parentNode.insertBefore(playerDiv, transcriptionBox.nextSibling);
            }
            
            // ğŸ¯ REAL TRANSCRIPTION - Send to server
            try {
                const progressBar = document.getElementById(`audioProgress_${timestamp}`);
                const statusText = document.getElementById(`audioStatus_${timestamp}`);
                const transcriptionDiv = document.getElementById(`transcriptionText_${timestamp}`);
                const transcriptionContent = document.getElementById(`transcriptionContent_${timestamp}`);
                
                // Show progress
                if (statusText) statusText.textContent = 'ğŸ“¤ ××¢×œ×” ×œ×©×¨×ª...';
                if (progressBar) progressBar.style.width = '10%';
                
                // Create FormData
                const formData = new FormData();
                formData.append('audio', file);
                formData.append('language', currentVoiceLang);
                formData.append('user_id', userId);
                
                if (statusText) statusText.textContent = 'ğŸ”„ ××ª××œ×œ...';
                if (progressBar) progressBar.style.width = '30%';
                
                // Send to server
                const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                    method: 'POST',
                    body: formData
                });
                
                if (progressBar) progressBar.style.width = '70%';
                
                if (response.ok) {
                    const result = await response.json();
                    const transcribedText = result.text || result.transcription || '[×œ× ×”×ª×§×‘×œ ×ª××œ×•×œ]';
                    
                    // ğŸ¯ Check if this is a MOCK response
                    const isMockResponse = transcribedText.includes('[') || 
                                          transcribedText.includes('×”×ª×§×‘×œ×” ×‘×”×¦×œ×—×”') ||
                                          transcribedText.includes('received successfully');
                    
                    if (progressBar) progressBar.style.width = '100%';
                    
                    if (isMockResponse) {
                        // MOCK Response - show warning
                        if (statusText) {
                            statusText.innerHTML = 'âš ï¸ ×ª××œ×•×œ MOCK - ×“×•×¨×© Whisper API!';
                            statusText.style.color = '#FFA500';
                        }
                        
                        // Show mock message + instructions
                        if (transcriptionDiv) transcriptionDiv.style.display = 'block';
                        if (transcriptionContent) {
                            transcriptionContent.innerHTML = `
                                <div style="color: #FFA500; font-weight: bold; margin-bottom: 10px;">
                                    âš ï¸ ×–×” ×ª××œ×•×œ ××–×•×™×£ (Mock)
                                </div>
                                <div style="color: white; margin-bottom: 10px;">
                                    ${transcribedText}
                                </div>
                                <div style="background: rgba(255,165,0,0.2); padding: 10px; border-radius: 6px; font-size: 0.9em; line-height: 1.6;">
                                    ğŸ’¡ <strong>×œ×ª××œ×•×œ ×××™×ª×™ ×¦×¨×™×š:</strong><br>
                                    1. OpenAI Whisper API key<br>
                                    2. ×œ×”×•×¡×™×£ ×‘×©×¨×ª (app.py)<br>
                                    3. ×¢×œ×•×ª: $0.006/×“×§×”<br>
                                    <br>
                                    <em>×›×¨×’×¢ ×”×©×¨×ª ×¨×§ ××§×‘×œ ××ª ×”×§×•×‘×¥ ××‘×œ ×œ× ××ª××œ×œ ××•×ª×•!</em>
                                </div>
                            `;
                        }
                        
                        addMessage(`âš ï¸ ${file.name} - ×ª××œ×•×œ MOCK (×“×•×¨×© Whisper API)`, false);
                    } else {
                        // REAL Response
                        if (statusText) {
                            statusText.textContent = 'âœ… ×ª××œ×•×œ ×”×•×©×œ×!';
                            statusText.style.color = '#FFD700';
                        }
                        
                        // Show transcription
                        if (transcriptionDiv) transcriptionDiv.style.display = 'block';
                        if (transcriptionContent) transcriptionContent.textContent = transcribedText;
                        
                        addMessage(`âœ… ${file.name} ×ª×•××œ×œ ×‘×”×¦×œ×—×”!`, false);
                    }
                    
                    // ğŸ§¬ Quantum Language Detection
                    const detectedLang = quantumDetector.detectLanguage(transcribedText);
                    const confidence = result.confidence || 0.85;
                    quantumDetector.updateCurrentLanguage(detectedLang, confidence);
                    
                    // Update file transcription
                    const fileIndex = uploadedFiles.findIndex(f => f.id === timestamp);
                    if (fileIndex >= 0) {
                        uploadedFiles[fileIndex].transcription = transcribedText;
                        uploadedFiles[fileIndex].transcriptionReady = true;
                        updateFilesList();
                    }
                    
                    // Store for download
                    window[`audioTranscription_${timestamp}`] = {
                        filename: file.name,
                        text: transcribedText,
                        timestamp: timestamp
                    };
                    
                    // Also update main transcript area
                    const savedText = document.getElementById('finalTranscript').getAttribute('data-saved') || '';
                    const newText = savedText ? savedText + '\n\nğŸ“„ ' + file.name + ':\n' + transcribedText : 'ğŸ“„ ' + file.name + ':\n' + transcribedText;
                    safeSetText('finalTranscript', newText);
                    document.getElementById('finalTranscript').setAttribute('data-saved', newText);
                    
                    addMessage(`âœ… ${file.name} ×ª×•××œ×œ ×‘×”×¦×œ×—×”!`, false);
                } else {
                    throw new Error(`Server error: ${response.status}`);
                }
                
            } catch (error) {
                console.error('Audio transcription error:', error);
                const statusText = document.getElementById(`audioStatus_${timestamp}`);
                const progressBar = document.getElementById(`audioProgress_${timestamp}`);
                
                if (statusText) {
                    statusText.textContent = `âŒ ×©×’×™××”: ${error.message}`;
                    statusText.style.color = '#ff4444';
                }
                if (progressBar) {
                    progressBar.style.width = '100%';
                    progressBar.style.background = '#ff4444';
                }
                
                addMessage(`âŒ ×ª××œ×•×œ ${file.name} × ×›×©×œ: ${error.message}`, false);
                
                // Store empty for download
                window[`audioTranscription_${timestamp}`] = {
                    filename: file.name,
                    text: '[×ª××œ×•×œ × ×›×©×œ]',
                    timestamp: timestamp
                };
            }
        }
        
        // Download functions for audio transcription
        function downloadAudioTranscription(timestamp, format) {
            const transcriptionData = window[`audioTranscription_${timestamp}`];
            if (!transcriptionData) {
                alert('××™×Ÿ ×ª××œ×•×œ ×–××™×Ÿ');
                return;
            }
            
            const transcriptionContent = document.getElementById(`transcriptionContent_${timestamp}`);
            const text = transcriptionContent ? transcriptionContent.textContent : transcriptionData.text;
            
            if (!text) {
                alert('×”×ª××œ×•×œ ×¢×“×™×™×Ÿ ×œ× ××•×›×Ÿ');
                return;
            }
            
            if (format === 'txt') {
                const content = `×—×™-×××ª - ×ª××œ×•×œ ××•×“×™×•\n${'='.repeat(50)}\n×§×•×‘×¥: ${transcriptionData.filename}\n×ª××¨×™×š: ${new Date().toLocaleString('he-IL')}\n${'='.repeat(50)}\n\n${text}`;
                const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                link.download = `transcription_${transcriptionData.filename.replace(/\.[^/.]+$/, '')}.txt`;
                link.click();
                addMessage(`ğŸ“„ ×”×•×¨×“: ${link.download}`, false);
            } else if (format === 'docx') {
                const doc = new docx.Document({
                    sections: [{
                        children: [
                            new docx.Paragraph({
                                text: 'ğŸµ ×—×™-×××ª - ×ª××œ×•×œ ××•×“×™×•',
                                heading: docx.HeadingLevel.HEADING_1,
                                spacing: { after: 400 }
                            }),
                            new docx.Paragraph({
                                text: `×§×•×‘×¥: ${transcriptionData.filename}`,
                                spacing: { after: 200 }
                            }),
                            new docx.Paragraph({
                                text: `×ª××¨×™×š: ${new Date().toLocaleString('he-IL')}`,
                                spacing: { after: 400 }
                            }),
                            new docx.Paragraph({
                                text: text,
                                spacing: { after: 200 }
                            })
                        ]
                    }]
                });
                
                docx.Packer.toBlob(doc).then(blob => {
                    const link = document.createElement('a');
                    link.href = URL.createObjectURL(blob);
                    link.download = `transcription_${transcriptionData.filename.replace(/\.[^/.]+$/, '')}.docx`;
                    link.click();
                    addMessage(`ğŸ“‹ ×”×•×¨×“: ${link.download}`, false);
                });
            }
        }
        
        async function handleVideoUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileData = {
                name: file.name,
                time: getPrecisionTime(),
                type: 'video',
                size: (file.size / 1024 / 1024).toFixed(2) + ' MB',
                transcription: 'â³ ××¢×‘×“ ×•×™×“××•...'
            };
            
            uploadedFiles.push(fileData);
            updateFilesList();
            addMessage(`ğŸ¬ ××¢×œ×”: ${file.name}...`, false);
            
            // Show video container
            const videoContainer = document.getElementById('videoContainer');
            videoContainer.style.display = 'block';
            
            // Create video player
            const videoURL = URL.createObjectURL(file);
            const videoPlayer = document.getElementById('videoPlayer');
            videoPlayer.src = videoURL;
            videoPlayer.style.display = 'block';
            videoPlayer.load();
            
            // Show video transcript area
            const videoTranscript = document.getElementById('videoTranscript');
            safeSetText('videoTranscript', 'ğŸ¬ ××¢×‘×“ ×•×™×“××•...');
            
            // Create progress indicator
            const videoPlayerWrapper = document.getElementById('videoPlayerWrapper');
            const progressHTML = `
                <div style="background: #f8f9fa; padding: 12px; border-radius: 8px; margin: 8px 0;">
                    <div style="font-weight: bold; margin-bottom: 8px;">ğŸ¬ ${file.name}</div>
                    <div style="background: #667eea; height: 4px; border-radius: 2px; overflow: hidden;">
                        <div id="videoProgress" style="background: #FFD700; height: 100%; width: 0%; transition: width 0.3s;"></div>
                    </div>
                    <div style="font-size: 0.85em; color: #667eea; margin-top: 6px;" id="videoProcessingStatus">
                        â³ ××¢×‘×“ ×›×ª×•×‘×™×•×ª... 0%
                    </div>
                </div>
            `;
            
            videoPlayerWrapper.insertAdjacentHTML('afterend', progressHTML);
            
            // Simulate subtitle processing
            let progress = 0;
            const subtitleSimulation = [
                '×©×œ×•×! ×–×” ×¡×¨×˜×•×Ÿ ×œ×“×•×’××...',
                '×”××¢×¨×›×ª ××¢×‘×“×ª ××ª ×”×•×™×“××• ×‘×–××Ÿ ×××ª',
                '×›×ª×•×‘×™×•×ª ××•×¤×™×¢×•×ª ×›××Ÿ ××•×˜×•××˜×™×ª',
                '×ª××œ×•×œ ××œ× ×™×•×¤×™×¢ ×‘×¡×™×•×'
            ];
            
            let currentSubIndex = 0;
            
            const progressInterval = setInterval(() => {
                progress += 5;
                const progressBar = document.getElementById('videoProgress');
                const statusText = document.getElementById('videoProcessingStatus');
                
                if (progressBar) {
                    progressBar.style.width = progress + '%';
                }
                if (statusText) {
                    statusText.textContent = `â³ ××¢×‘×“... ${progress}%`;
                }
                
                // Update subtitles simulation
                if (progress % 25 === 0 && currentSubIndex < subtitleSimulation.length) {
                    safeSetText('videoTranscript', subtitleSimulation[currentSubIndex]);
                    currentSubIndex++;
                }
                
                if (progress >= 100) {
                    clearInterval(progressInterval);
                    if (statusText) {
                        statusText.textContent = 'âœ… ×›×ª×•×‘×™×•×ª ××•×›× ×•×ª!';
                        statusText.style.color = '#28a745';
                    }
                    
                    safeSetText('videoTranscript', 'âœ… ×ª××œ×•×œ ×”×©×ª×œ× - ×œ×—×¥ Play ×›×“×™ ×œ×¨××•×ª ××ª ×”×¡×¨×˜×•×Ÿ');
                    
                    // Update file transcription
                    const lastFile = uploadedFiles[uploadedFiles.length - 1];
                    if (lastFile) {
                        lastFile.transcription = '[×›×ª×•×‘×™×•×ª: ' + subtitleSimulation.join(' | ') + ']';
                        updateFilesList();
                    }
                    
                    addMessage(`âœ… ${file.name} ××•×›×Ÿ ×¢× ×›×ª×•×‘×™×•×ª!`, false);
                }
            }, 200);
            
            // Real-time subtitle display when video plays
            videoPlayer.addEventListener('timeupdate', function() {
                const currentTime = this.currentTime;
                const duration = this.duration;
                
                if (duration > 0) {
                    const percentage = (currentTime / duration) * 100;
                    
                    // Show different subtitles based on video time
                    if (currentTime < duration * 0.25) {
                        safeSetText('videoTranscript', 'ğŸ“º ' + subtitleSimulation[0]);
                    } else if (currentTime < duration * 0.5) {
                        safeSetText('videoTranscript', 'ğŸ“º ' + subtitleSimulation[1]);
                    } else if (currentTime < duration * 0.75) {
                        safeSetText('videoTranscript', 'ğŸ“º ' + subtitleSimulation[2]);
                    } else {
                        safeSetText('videoTranscript', 'ğŸ“º ' + subtitleSimulation[3]);
                    }
                }
            });
        }
        
        function handleTxtUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result;
                const lines = content.split('\n').filter(l => l.trim());
                
                const fileData = {
                    name: file.name,
                    time: getPrecisionTime(),
                    type: 'txt',
                    size: (file.size / 1024).toFixed(2) + ' KB',
                    transcription: lines.slice(0, 3).join('\n...')
                };
                
                uploadedFiles.push(fileData);
                updateFilesList();
                addMessage(`ğŸ“„ ×”×•×¢×œ×”: ${file.name} (${lines.length} ×©×•×¨×•×ª)`, false);
            };
            reader.readAsText(file);
        }
        
        function handleDocxUpload(event) {
            const file = event.target.files[0];
            if (!file) return;
            
            const fileData = {
                name: file.name,
                time: getPrecisionTime(),
                type: 'docx',
                size: (file.size / 1024).toFixed(2) + ' KB',
                transcription: 'â³ ××¢×‘×“×ª DOCX...'
            };
            
            uploadedFiles.push(fileData);
            updateFilesList();
            addMessage(`ğŸ“‹ ×”×¢×œ××”: ${file.name}`, false);
        }
        
        function updateFilesList() {
            const filesList = document.getElementById('filesList');
            
            if (uploadedFiles.length === 0) {
                filesList.innerHTML = '<div class="empty-files">××™×Ÿ ×§×‘×¦×™× ×¢×“×™×™×Ÿ</div>';
                return;
            }
            
            filesList.innerHTML = '';
            uploadedFiles.forEach((file) => {
                const fileEl = document.createElement('div');
                fileEl.className = 'file-item';
                
                let icon = 'ğŸ“„';
                if (file.type === 'txt') icon = 'ğŸ“„';
                if (file.type === 'docx') icon = 'ğŸ“‹';
                if (file.type === 'audio') icon = 'ğŸµ';
                if (file.type === 'video') icon = 'ğŸ¬';
                
                let details = `${file.time}s`;
                if (file.size) details += ` | ${file.size}`;
                
                let html = `
                    <div class="file-name">${icon} ${file.name}</div>
                    <div style="font-size: 0.7em; color: #999;">${details}</div>
                `;
                
                if (file.transcription) {
                    html += `<div class="file-transcription">${file.transcription}</div>`;
                }
                
                fileEl.innerHTML = html;
                filesList.appendChild(fileEl);
            });
        }
        
        function clearAllFiles() {
            if (confirm('×‘×˜×•×—?')) {
                uploadedFiles = [];
                transcriptionHistory = [];
                updateFilesList();
                safeSetText('finalTranscript', '');
                safeSetText('translatedText', '');
            }
        }
        
        function toggleStreamAccordion(element) {
            const accordion = document.getElementById('streamAccordion');
            const arrow = element.textContent.includes('â–¶') ? 'â–¼' : 'â–¶';
            element.textContent = element.textContent.replace(/[â–¶â–¼]/, arrow) + ' ×•×™×“××• / ×©×“×•×¨ ×—×™';
            accordion.style.display = accordion.style.display === 'none' ? 'block' : 'none';
        }
        
        function showYouTubeInput() {
            document.getElementById('youtubeInputArea').style.display = 'block';
            document.getElementById('liveStreamInputArea').style.display = 'none';
        }
        
        function showLiveStreamInput() {
            document.getElementById('youtubeInputArea').style.display = 'none';
            document.getElementById('liveStreamInputArea').style.display = 'block';
        }
        
        async function loadYouTubeVideo() {
            const url = document.getElementById('youtubeURL').value.trim();
            if (!url) {
                alert('×”×›× ×¡ YouTube URL');
                return;
            }
            
            let videoId = '';
            if (url.includes('youtu.be/')) {
                videoId = url.split('youtu.be/')[1].split('?')[0];
            } else if (url.includes('v=')) {
                videoId = url.split('v=')[1].split('&')[0];
            }
            
            if (videoId) {
                document.getElementById('videoContainer').style.display = 'block';
                const videoPlayerWrapper = document.getElementById('videoPlayerWrapper');
                videoPlayerWrapper.innerHTML = '';
                
                // Create container for video + controls
                const container = document.createElement('div');
                container.style.marginBottom = '15px';
                
                const iframe = document.createElement('iframe');
                iframe.width = '100%';
                iframe.height = '380';
                iframe.src = `https://www.youtube.com/embed/${videoId}?enablejsapi=1`;
                iframe.title = 'YouTube video player';
                iframe.frameBorder = '0';
                iframe.allow = 'accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture';
                iframe.allowFullscreen = true;
                iframe.style.borderRadius = '8px';
                container.appendChild(iframe);
                
                // Add transcription controls
                const controlsDiv = document.createElement('div');
                controlsDiv.style.cssText = 'margin-top: 12px; padding: 12px; background: rgba(102, 126, 234, 0.1); border-radius: 8px;';
                controlsDiv.innerHTML = `
                    <button onclick="fetchYouTubeCaptions('${videoId}')" style="background: #667eea; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer; margin-right: 8px;">
                        ğŸ“¥ ×”×•×¨×“ ×›×ª×•×‘×™×•×ª
                    </button>
                    <button onclick="captureYouTubeAudio('${videoId}')" style="background: #FF0000; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer;">
                        ğŸ¤ ×”×§×œ×˜ ××•×“×™×• ××”×¡×¨×˜×•×Ÿ
                    </button>
                    <div id="ytTranscript_${videoId}" style="margin-top: 12px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; color: white; display: none; direction: rtl; text-align: right;"></div>
                `;
                container.appendChild(controlsDiv);
                
                videoPlayerWrapper.appendChild(container);
                
                addMessage(`ğŸ“º YouTube: ${url.substring(0, 50)}...`, false);
                addMessage(`ğŸ’¡ ×œ×—×¥ "ğŸ“¥ ×”×•×¨×“ ×›×ª×•×‘×™×•×ª" ×× ×”×¡×¨×˜×•×Ÿ ×›×•×œ×œ ×›×ª×•×‘×™×•×ª, ××• "ğŸ¤ ×”×§×œ×˜ ××•×“×™×•" ×œ×”×§×œ×˜×” ×™×“× ×™×ª`, false);
            }
        }
        
        // Fetch YouTube Captions
        async function fetchYouTubeCaptions(videoId) {
            try {
                addMessage('ğŸ” ××—×¤×© ×›×ª×•×‘×™×•×ª...', false);
                
                // Try to fetch captions using YouTube's timedtext API
                const languages = ['he', 'iw', 'en', 'auto'];
                let captionsFound = false;
                
                for (const lang of languages) {
                    try {
                        const captionsUrl = `https://www.youtube.com/api/timedtext?v=${videoId}&lang=${lang}`;
                        const response = await fetch(captionsUrl, { mode: 'cors' });
                        
                        if (response.ok) {
                            const xmlText = await response.text();
                            
                            // Parse XML captions
                            const parser = new DOMParser();
                            const xmlDoc = parser.parseFromString(xmlText, 'text/xml');
                            const textNodes = xmlDoc.getElementsByTagName('text');
                            
                            let fullText = '';
                            for (let i = 0; i < textNodes.length; i++) {
                                fullText += textNodes[i].textContent + ' ';
                            }
                            
                            if (fullText.trim()) {
                                captionsFound = true;
                                
                                // ğŸ¯ Display captions in MAIN videoTranscript area
                                const mainVideoTranscript = document.getElementById('videoTranscript');
                                if (mainVideoTranscript) {
                                    mainVideoTranscript.textContent = fullText.trim();
                                    mainVideoTranscript.style.color = 'white';
                                }
                                
                                // Also display in local div (backup)
                                const transcriptDiv = document.getElementById(`ytTranscript_${videoId}`);
                                if (transcriptDiv) {
                                    transcriptDiv.style.display = 'block';
                                    transcriptDiv.innerHTML = `<strong>ğŸ“ ×›×ª×•×‘×™×•×ª (${lang}):</strong><br>${fullText.trim()}`;
                                }
                                
                                // Save to videoTranscriptHistory
                                videoTranscriptHistory.push({
                                    text: fullText.trim(),
                                    time: getExactTime(),
                                    source: 'youtube',
                                    videoId: videoId,
                                    language: lang
                                });
                                
                                // Save for download
                                window[`ytCaptions_${videoId}`] = {
                                    text: fullText.trim(),
                                    videoId: videoId,
                                    language: lang
                                };
                                
                                addMessage(`âœ… ×›×ª×•×‘×™×•×ª × ××¦××•! (${lang})`, false);
                                
                                // Add download buttons
                                const controlsDiv = transcriptDiv.parentElement;
                                if (controlsDiv && !document.getElementById(`ytDownloadBtns_${videoId}`)) {
                                    const downloadDiv = document.createElement('div');
                                    downloadDiv.id = `ytDownloadBtns_${videoId}`;
                                    downloadDiv.style.cssText = 'margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;';
                                    downloadDiv.innerHTML = `
                                        <button onclick="downloadYouTubeCaptions('${videoId}', 'txt')" style="background: #28a745; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                            ğŸ“„ ×”×•×¨×“ TXT
                                        </button>
                                        <button onclick="downloadYouTubeCaptions('${videoId}', 'docx')" style="background: #17a2b8; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                            ğŸ“‹ ×”×•×¨×“ DOCX
                                        </button>
                                    `;
                                    controlsDiv.appendChild(downloadDiv);
                                }
                                
                                break;
                            }
                        }
                    } catch (e) {
                        console.log(`No captions for lang: ${lang}`);
                    }
                }
                
                if (!captionsFound) {
                    addMessage('âš ï¸ ×œ× × ××¦××• ×›×ª×•×‘×™×•×ª. × ×¡×” "ğŸ¤ ×”×§×œ×˜ ××•×“×™×•" ×‘××§×•×.', false);
                }
                
            } catch (error) {
                console.error('YouTube captions error:', error);
                addMessage(`âŒ ×©×’×™××” ×‘×”×•×¨×“×ª ×›×ª×•×‘×™×•×ª: ${error.message}`, false);
            }
        }
        
        // Capture YouTube Audio (requires user permission)
        async function captureYouTubeAudio(videoId) {
            try {
                addMessage('ğŸ¤ ×”×¤×¢×œ ××ª ×”×¡×¨×˜×•×Ÿ ×•×œ×—×¥ ××™×©×•×¨ ×›×“×™ ×œ×”×§×œ×™×˜ ××ª ×”××•×“×™×•...', false);
                
                // Request screen/tab capture with audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                // Create recorder
                const recorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp8,opus'
                });
                
                const chunks = [];
                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                
                recorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    
                    addMessage('ğŸ“¤ ××¢×œ×” ××•×“×™×• ×œ×ª××œ×•×œ...', false);
                    
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const formData = new FormData();
                    formData.append('audio', blob, `youtube_${videoId}.webm`);
                    formData.append('language', currentVoiceLang);
                    formData.append('user_id', userId);
                    
                    try {
                        const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            const transcribedText = result.text || '[×œ× ×”×ª×§×‘×œ ×ª××œ×•×œ]';
                            
                            // Display
                            const transcriptDiv = document.getElementById(`ytTranscript_${videoId}`);
                            if (transcriptDiv) {
                                transcriptDiv.style.display = 'block';
                                transcriptDiv.innerHTML = `<strong>ğŸ“ ×ª××œ×•×œ:</strong><br>${transcribedText}`;
                            }
                            
                            // Save for download
                            window[`ytCaptions_${videoId}`] = {
                                text: transcribedText,
                                videoId: videoId,
                                language: 'transcribed'
                            };
                            
                            addMessage(`âœ… ×ª××œ×•×œ ×”×•×©×œ×!`, false);
                            
                            // Add download buttons if not exist
                            const controlsDiv = transcriptDiv.parentElement;
                            if (controlsDiv && !document.getElementById(`ytDownloadBtns_${videoId}`)) {
                                const downloadDiv = document.createElement('div');
                                downloadDiv.id = `ytDownloadBtns_${videoId}`;
                                downloadDiv.style.cssText = 'margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;';
                                downloadDiv.innerHTML = `
                                    <button onclick="downloadYouTubeCaptions('${videoId}', 'txt')" style="background: #28a745; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                        ğŸ“„ ×”×•×¨×“ TXT
                                    </button>
                                    <button onclick="downloadYouTubeCaptions('${videoId}', 'docx')" style="background: #17a2b8; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                        ğŸ“‹ ×”×•×¨×“ DOCX
                                    </button>
                                `;
                                controlsDiv.appendChild(downloadDiv);
                            }
                        } else {
                            addMessage(`âŒ ×©×’×™××ª ×ª××œ×•×œ: ${response.status}`, false);
                        }
                    } catch (error) {
                        addMessage(`âŒ ×©×’×™××”: ${error.message}`, false);
                    }
                };
                
                // Start recording
                recorder.start();
                addMessage('ğŸ”´ ××§×œ×™×˜... ×œ×—×¥ "×¢×¦×•×¨ ×©×™×ª×•×£" ×›×“×™ ×œ×¡×™×™×', false);
                
                // Auto-stop after stream ends
                stream.getVideoTracks()[0].addEventListener('ended', () => {
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                });
                
            } catch (error) {
                console.error('YouTube audio capture error:', error);
                addMessage(`âŒ ×œ× × ×™×ª×Ÿ ×œ×”×§×œ×™×˜: ${error.message}`, false);
            }
        }
        
        // Download YouTube captions
        function downloadYouTubeCaptions(videoId, format) {
            const data = window[`ytCaptions_${videoId}`];
            if (!data || !data.text) {
                alert('××™×Ÿ ×ª××œ×•×œ ×–××™×Ÿ ×œ×”×•×¨×“×”');
                return;
            }
            
            const filename = `youtube_${videoId}_captions`;
            
            if (format === 'txt') {
                const blob = new Blob([data.text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.txt';
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'docx') {
                if (typeof docx === 'undefined') {
                    alert('docx.js ×œ× ×˜×¢×•×Ÿ');
                    return;
                }
                
                const doc = new docx.Document({
                    sections: [{
                        properties: {},
                        children: [
                            new docx.Paragraph({
                                text: `YouTube Video: ${videoId}`,
                                heading: docx.HeadingLevel.HEADING_1,
                                spacing: { after: 200 }
                            }),
                            new docx.Paragraph({
                                text: data.text,
                                spacing: { line: 360 }
                            })
                        ]
                    }]
                });
                
                docx.Packer.toBlob(doc).then(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename + '.docx';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        }
        
        // ğŸ¬ Live Stream Transcriber class
        class LiveStreamTranscriber {
            constructor() {
                this.stream = null;
                this.recorder = null;
                this.isRecording = false;
                this.videoElement = null;
            }
            
            detectStreamType(url) {
                if (url.includes('.m3u8')) return { type: 'HLS', protocol: 'm3u8' };
                if (url.includes('.mpd')) return { type: 'DASH', protocol: 'mpd' };
                if (url.includes('rtmp://')) return { type: 'RTMP', protocol: 'rtmp' };
                if (url.includes('.mp4')) return { type: 'MP4', protocol: 'mp4' };
                return { type: 'Unknown', protocol: 'unknown' };
            }
            
            async loadStream(url, container) {
                try {
                    const streamType = this.detectStreamType(url);
                    
                    // Create video element
                    this.videoElement = document.createElement('video');
                    this.videoElement.controls = true;
                    this.videoElement.style.width = '100%';
                    this.videoElement.style.borderRadius = '8px';
                    this.videoElement.crossOrigin = 'anonymous';
                    
                    // Try to load based on type
                    if (streamType.type === 'HLS') {
                        // For HLS, we need hls.js
                        if (typeof Hls !== 'undefined' && Hls.isSupported()) {
                            const hls = new Hls();
                            hls.loadSource(url);
                            hls.attachMedia(this.videoElement);
                        } else {
                            this.videoElement.src = url;
                        }
                    } else {
                        this.videoElement.src = url;
                    }
                    
                    // Add controls for capture
                    const controlsDiv = document.createElement('div');
                    controlsDiv.style.cssText = 'margin-top: 12px; padding: 12px; background: rgba(102, 126, 234, 0.1); border-radius: 8px;';
                    controlsDiv.innerHTML = `
                        <button onclick="captureStreamAudio()" style="background: #FF0000; color: white; border: none; padding: 10px 15px; border-radius: 8px; cursor: pointer;">
                            ğŸ¤ ×”×§×œ×˜ ××•×“×™×• ××”×©×™×“×•×¨
                        </button>
                        <div id="streamTranscript" style="margin-top: 12px; padding: 12px; background: rgba(0,0,0,0.3); border-radius: 8px; color: white; display: none; direction: rtl; text-align: right;"></div>
                    `;
                    
                    container.innerHTML = '';
                    container.appendChild(this.videoElement);
                    container.appendChild(controlsDiv);
                    
                    return true;
                } catch (error) {
                    console.error('Stream load error:', error);
                    return false;
                }
            }
            
            async startLiveTranscription(language, outputElement) {
                // This is a placeholder - actual implementation would capture audio
                console.log('Live transcription started');
            }
        }
        
        // Capture stream audio
        async function captureStreamAudio() {
            try {
                addMessage('ğŸ¤ ×”×¤×¢×œ ××ª ×”×©×™×“×•×¨ ×•×œ×—×¥ ××™×©×•×¨ ×›×“×™ ×œ×”×§×œ×™×˜...', false);
                
                // Request screen/tab capture with audio
                const stream = await navigator.mediaDevices.getDisplayMedia({
                    video: true,
                    audio: {
                        echoCancellation: false,
                        noiseSuppression: false,
                        autoGainControl: false
                    }
                });
                
                // Create recorder
                const recorder = new MediaRecorder(stream, {
                    mimeType: 'video/webm;codecs=vp8,opus'
                });
                
                const chunks = [];
                recorder.ondataavailable = (e) => {
                    if (e.data.size > 0) chunks.push(e.data);
                };
                
                recorder.onstop = async () => {
                    stream.getTracks().forEach(track => track.stop());
                    
                    addMessage('ğŸ“¤ ××¢×œ×” ××•×“×™×• ×œ×ª××œ×•×œ...', false);
                    
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    const formData = new FormData();
                    formData.append('audio', blob, 'stream_capture.webm');
                    formData.append('language', currentVoiceLang);
                    formData.append('user_id', userId);
                    
                    try {
                        const response = await fetch('https://haiemetweb.onrender.com/transcribe', {
                            method: 'POST',
                            body: formData
                        });
                        
                        if (response.ok) {
                            const result = await response.json();
                            const transcribedText = result.text || '[×œ× ×”×ª×§×‘×œ ×ª××œ×•×œ]';
                            
                            // Display
                            const transcriptDiv = document.getElementById('streamTranscript');
                            if (transcriptDiv) {
                                transcriptDiv.style.display = 'block';
                                transcriptDiv.innerHTML = `<strong>ğŸ“ ×ª××œ×•×œ:</strong><br>${transcribedText}`;
                            }
                            
                            // Save for download
                            window.streamCaptureTranscript = transcribedText;
                            
                            addMessage(`âœ… ×ª××œ×•×œ ×”×©×™×“×•×¨ ×”×•×©×œ×!`, false);
                            
                            // Add download buttons
                            if (transcriptDiv && !document.getElementById('streamDownloadBtns')) {
                                const downloadDiv = document.createElement('div');
                                downloadDiv.id = 'streamDownloadBtns';
                                downloadDiv.style.cssText = 'margin-top: 12px; display: grid; grid-template-columns: 1fr 1fr; gap: 8px;';
                                downloadDiv.innerHTML = `
                                    <button onclick="downloadStreamTranscript('txt')" style="background: #28a745; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                        ğŸ“„ ×”×•×¨×“ TXT
                                    </button>
                                    <button onclick="downloadStreamTranscript('docx')" style="background: #17a2b8; color: white; border: none; padding: 10px; border-radius: 8px; cursor: pointer;">
                                        ğŸ“‹ ×”×•×¨×“ DOCX
                                    </button>
                                `;
                                transcriptDiv.parentElement.appendChild(downloadDiv);
                            }
                        } else {
                            addMessage(`âŒ ×©×’×™××ª ×ª××œ×•×œ: ${response.status}`, false);
                        }
                    } catch (error) {
                        addMessage(`âŒ ×©×’×™××”: ${error.message}`, false);
                    }
                };
                
                // Start recording
                recorder.start();
                addMessage('ğŸ”´ ××§×œ×™×˜... ×œ×—×¥ "×¢×¦×•×¨ ×©×™×ª×•×£" ×›×“×™ ×œ×¡×™×™×', false);
                
                // Auto-stop after stream ends
                stream.getVideoTracks()[0].addEventListener('ended', () => {
                    if (recorder.state === 'recording') {
                        recorder.stop();
                    }
                });
                
            } catch (error) {
                console.error('Stream audio capture error:', error);
                addMessage(`âŒ ×œ× × ×™×ª×Ÿ ×œ×”×§×œ×™×˜: ${error.message}`, false);
            }
        }
        
        // Download stream transcript
        function downloadStreamTranscript(format) {
            const text = window.streamCaptureTranscript;
            if (!text) {
                alert('××™×Ÿ ×ª××œ×•×œ ×–××™×Ÿ ×œ×”×•×¨×“×”');
                return;
            }
            
            const filename = 'stream_transcript';
            
            if (format === 'txt') {
                const blob = new Blob([text], { type: 'text/plain;charset=utf-8' });
                const url = URL.createObjectURL(blob);
                const a = document.createElement('a');
                a.href = url;
                a.download = filename + '.txt';
                a.click();
                URL.revokeObjectURL(url);
            } else if (format === 'docx') {
                if (typeof docx === 'undefined') {
                    alert('docx.js ×œ× ×˜×¢×•×Ÿ');
                    return;
                }
                
                const doc = new docx.Document({
                    sections: [{
                        properties: {},
                        children: [
                            new docx.Paragraph({
                                text: 'Stream Transcription',
                                heading: docx.HeadingLevel.HEADING_1,
                                spacing: { after: 200 }
                            }),
                            new docx.Paragraph({
                                text: text,
                                spacing: { line: 360 }
                            })
                        ]
                    }]
                });
                
                docx.Packer.toBlob(doc).then(blob => {
                    const url = URL.createObjectURL(blob);
                    const a = document.createElement('a');
                    a.href = url;
                    a.download = filename + '.docx';
                    a.click();
                    URL.revokeObjectURL(url);
                });
            }
        }
        
        // ğŸ¬ Live Stream Transcriber instance
        let streamTranscriber = null;
        
        async function loadLiveStream() {
            const url = document.getElementById('streamURL2').value.trim();
            if (!url) {
                alert('×”×›× ×¡ Stream URL');
                return;
            }
            
            try {
                // Create transcriber if not exists
                if (!streamTranscriber) {
                    streamTranscriber = new LiveStreamTranscriber();
                }
                
                // Detect stream type
                const streamType = streamTranscriber.detectStreamType(url);
                addMessage(`ğŸ¬ ××–×”×” ×¡×•×’ stream: ${streamType.type}`, false);
                
                // Get video container
                const videoContainer = document.getElementById('videoContainer');
                videoContainer.style.display = 'block';
                
                // Load stream
                const loaded = await streamTranscriber.loadStream(url, videoContainer);
                
                if (loaded) {
                    addMessage(`âœ… Stream ×˜×¢×•×Ÿ: ${streamType.type}`, false);
                    updateStatus('ğŸ¬ Stream ready - click START to transcribe');
                    
                    // Start live transcription automatically
                    const outputEl = document.getElementById('videoTranscript');
                    streamTranscriber.startLiveTranscription(currentVoiceLang, outputEl);
                    
                    safeSetText('videoTranscript', 'ğŸ¬ ×ª××œ×•×œ ×‘×–××Ÿ ×××ª ×”×ª×—×™×œ...');
                } else {
                    addMessage(`âŒ ×œ× × ×™×ª×Ÿ ×œ×˜×¢×•×Ÿ ××ª ×”-stream`, false);
                }
                
            } catch (error) {
                console.error('Stream load error:', error);
                addMessage(`âŒ ×©×’×™××” ×‘×˜×¢×™× ×ª ×©×™×“×•×¨: ${error.message}`, false);
            }
        }
        
        async function processVideoSubtitles() {
            const subtitles = document.getElementById('videoSubtitles').value.trim();
            if (!subtitles) {
                alert('×”×›× ×¡ ×˜×§×¡×˜ ××”×¡×¨×˜×•×Ÿ');
                return;
            }
            
            currentVideoSubtitles = subtitles;
            currentVideoTranslations = {};
            
            const langName = LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown';
            const display = `[${langName}]\n\n${subtitles}`;
            safeSetText('videoTranscript', display);
            
            const videoSubEl = document.getElementById('videoSubtitles');
            if (videoSubEl) videoSubEl.value = subtitles;
            
            videoTranscriptHistory = [{
                text: subtitles,
                time: getExactTime(),
                lang: currentVoiceLang
            }];
            
            addMessage(`ğŸ¬ ×¢×“×›×Ÿ ×›×ª×•×‘×™×•×ª: ${subtitles.substring(0, 30)}...`, false);
            const langSelect = document.getElementById('videoTranslang');
            if (langSelect) langSelect.focus();
        }
        
        async function updateVideoTranslation() {
            const targetLang = document.getElementById('videoTranslang').value;
            if (!targetLang || !currentVideoSubtitles) return;
            
            safeSetText('videoTranscript', 'â³ ××ª×¨×’×...');
            
            try {
                const translated = await translateVideoText(currentVideoSubtitles, targetLang);
                currentVideoTranslations[targetLang] = translated;
                
                const langName = LANGUAGES_CONFIG[targetLang]?.name || targetLang.toUpperCase();
                const display = `[${langName}]\n\n${translated}`;
                safeSetText('videoTranscript', display);
                
                videoTranscriptHistory.push({
                    text: translated,
                    time: getExactTime(),
                    lang: targetLang,
                    translated_from: currentVoiceLang,
                    original: currentVideoSubtitles
                });
                
            } catch (e) {
                safeSetText('videoTranscript', 'âŒ ×©×’×™××” ×‘×ª×¨×’×•×');
            }
        }
        
        async function saveVideoTranscriptTXT() {
            if (!currentVideoSubtitles) {
                alert('××™×Ÿ ×›×ª×•×‘×™×•×ª ×œ×©××•×¨');
                return;
            }
            
            let content = `×—×™-×××ª - ×›×ª×•×‘×™×•×ª ×¡×¨×˜×•×Ÿ\n`;
            content += `=${'='.repeat(50)}\n`;
            content += `×ª××¨×™×š: ${new Date().toLocaleString('he-IL')}\n`;
            content += `×©×¤×” ××§×•×¨: ${LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown'}\n`;
            content += `=${'='.repeat(50)}\n\n`;
            content += `ğŸ“º ×˜×§×¡×˜ ××§×•×¨:\n${currentVideoSubtitles}\n\n`;
            
            if (Object.keys(currentVideoTranslations).length > 0) {
                content += `ğŸŒ ×ª×¨×’×•××™×:\n${'-'.repeat(50)}\n`;
                for (const [lang, text] of Object.entries(currentVideoTranslations)) {
                    content += `\n[${lang.toUpperCase()}]\n${text}\n`;
                }
            }
            
            const blob = new Blob([content], { type: 'text/plain;charset=utf-8' });
            const link = document.createElement('a');
            link.href = URL.createObjectURL(blob);
            const filename = `video_subtitles_${Date.now()}.txt`;
            link.download = filename;
            link.click();
            
            uploadedFiles.push({
                name: filename,
                time: getPrecisionTime(),
                type: 'video_txt',
                size: (blob.size / 1024).toFixed(2) + ' KB'
            });
            updateFilesList();
            addMessage(`ğŸ“„ ×©××•×¨: ${filename}`, false);
        }
        
        async function saveVideoTranscriptDOCX() {
            if (!currentVideoSubtitles) {
                alert('××™×Ÿ ×›×ª×•×‘×™×•×ª ×œ×©××•×¨');
                return;
            }
            
            const sections = [];
            
            sections.push(new docx.Paragraph({
                text: 'ğŸ“º ×›×ª×•×‘×™×•×ª ×¡×¨×˜×•×Ÿ - ×—×™-×××ª',
                heading: docx.HeadingLevel.HEADING_1,
                spacing: { after: 200 }
            }));
            
            sections.push(new docx.Paragraph({
                text: `×ª××¨×™×š: ${new Date().toLocaleString('he-IL')} | ×©×¤×”: ${LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown'}`,
                spacing: { after: 400 }
            }));
            
            sections.push(new docx.Paragraph({
                text: '×˜×§×¡×˜ ××§×•×¨:',
                heading: docx.HeadingLevel.HEADING_2,
                spacing: { after: 200 }
            }));
            
            sections.push(new docx.Paragraph({
                text: currentVideoSubtitles,
                spacing: { after: 400 }
            }));
            
            if (Object.keys(currentVideoTranslations).length > 0) {
                sections.push(new docx.Paragraph({
                    text: '×ª×¨×’×•××™×:',
                    heading: docx.HeadingLevel.HEADING_2,
                    spacing: { after: 200 }
                }));
                
                for (const [lang, text] of Object.entries(currentVideoTranslations)) {
                    sections.push(new docx.Paragraph({
                        text: lang.toUpperCase(),
                        heading: docx.HeadingLevel.HEADING_3,
                        spacing: { after: 100 }
                    }));
                    
                    sections.push(new docx.Paragraph({
                        text: text,
                        spacing: { after: 200 }
                    }));
                }
            }
            
            const doc = new docx.Document({
                sections: [{ children: sections }]
            });
            
            docx.Packer.toBlob(doc).then(blob => {
                const link = document.createElement('a');
                link.href = URL.createObjectURL(blob);
                const filename = `video_subtitles_${Date.now()}.docx`;
                link.download = filename;
                link.click();
                
                uploadedFiles.push({
                    name: filename,
                    time: getPrecisionTime(),
                    type: 'video_docx',
                    size: (blob.size / 1024).toFixed(2) + ' KB'
                });
                updateFilesList();
                addMessage(`ğŸ“‹ ×©××•×¨: ${filename}`, false);
            });
        }
        
        async function translateVideoText(text, targetLang) {
            try {
                const response = await fetch(`https://api.mymemory.translated.net/get?q=${encodeURIComponent(text)}&langpair=${getLangCode(currentVoiceLang)}|${targetLang}`);
                const data = await response.json();
                return data.responseStatus === 200 ? data.responseData.translatedText : '';
            } catch (e) {
                return '';
            }
        }
        
        async function startAudioStreaming() {
            try {
                // Get optimized audio constraints
                const constraints = getOptimizedAudioConstraints();
                
                const stream = await navigator.mediaDevices.getUserMedia(constraints);
                
                // Get audio track info
                const audioTrack = stream.getAudioTracks()[0];
                const settings = audioTrack.getSettings();
                
                // Update display with actual settings
                safeSetText('sampleRate', `${settings.sampleRate}Hz`);
                safeSetText('noiseSuppression', settings.noiseSuppression ? 'âœ…' : 'âš ï¸');
                
                mediaRecorder = new MediaRecorder(stream, {
                    mimeType: 'audio/webm;codecs=opus',
                    audioBitsPerSecond: 256000 // High bitrate for quality
                });
                
                audioChunks = [];
                isAudioRecording = true;
                
                mediaRecorder.ondataavailable = (event) => {
                    audioChunks.push(event.data);
                };
                
                mediaRecorder.onstop = () => {
                    const audioBlob = new Blob(audioChunks, { type: 'audio/webm' });
                    saveAudioStream(audioBlob);
                };
                
                mediaRecorder.start();
                updateStatus(`ğŸ™ï¸ ×”×§×œ×˜×ª ××•×“×™×• ×‘×¨××” ××•×¤×˜×™××œ×™×ª (${settings.sampleRate}Hz)...`);
                addMessage(`ğŸ™ï¸ ×”×§×œ×˜×”: ${availableAudioDevices.find(d => d.deviceId === selectedAudioDevice)?.label || '××™×§×¨×•×¤×•×Ÿ ×‘×¨×™×¨×ª ××—×“×œ'}`, false);
                
            } catch (error) {
                alert('×©×’×™××”: ' + error.message);
                updateStatus('âŒ ×©×’×™××” ×‘×”×§×œ×˜×”');
            }
        }
        
        function stopAudioStreaming() {
            // Stop live stream transcriber if active
            if (streamTranscriber) {
                streamTranscriber.stopStream();
                streamTranscriber.stopLiveTranscription();
            }
            
            // Stop media recorder
            if (mediaRecorder && isAudioRecording) {
                mediaRecorder.stop();
                isAudioRecording = false;
                updateStatus('âœ… ××•×“×™×• ×©××•×¨');
                mediaRecorder.stream.getTracks().forEach(track => track.stop());
            }
        }
        
        function saveAudioStream(audioBlob) {
            const url = URL.createObjectURL(audioBlob);
            const link = document.createElement('a');
            link.href = url;
            const filename = `audio_stream_${Date.now()}.webm`;
            link.download = filename;
            link.click();
            
            uploadedFiles.push({
                name: filename,
                time: getPrecisionTime(),
                type: 'audio_stream',
                size: (audioBlob.size / 1024).toFixed(2) + ' KB'
            });
            updateFilesList();
            addMessage(`ğŸµ ××•×“×™×• ×©××•×¨ ×‘×¨××” ×’×‘×•×”×”: ${filename}`, false);
        }
        
        document.addEventListener('keypress', (e) => {
            if (e.key === 'Enter' && e.target.id === 'messageInput') {
                e.preventDefault();
                sendMessage();
            }
        });
        
        console.log('âœ… Hai-Emet VOICE System Ready!');
        console.log('Binary: ' + BINARY_SIG);
    </script>
</body>
</html>
