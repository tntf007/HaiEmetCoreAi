// ============================================
// ðŸ”§ ×§×•×“ ×ž×•×›×Ÿ #1 - ×ž×©×ª× ×” ×’×œ×•×‘×œ
// ============================================
// ×”×•×¡×£ ×‘×“×™×•×§ ××—×¨×™ ×©×•×¨×”: let userId = 'user_' + Math.random().toString(36).substr(2, 9);

let currentTranscriptionText = '';  // âœ… ×ž×©×ª× ×” ×’×œ×•×‘×œ ×œ×˜×§×¡×˜ ×”×”×§×œ×˜×”


// ============================================
// ðŸ”§ ×§×•×“ ×ž×•×›×Ÿ #2 - clearTranscription()
// ============================================
// ×”×—×œ×£ ××ª ×›×œ ×”×¤×•× ×§×¦×™×” ×”×–×•:

function clearTranscription() {
    if (confirm('×‘×˜×•×— ×©×¨×•×¦×” ×œ×ž×—×•×§ ××ª ×›×œ ×”×˜×§×¡×˜?')) {
        currentTranscriptionText = '';
        document.getElementById('finalTranscript').textContent = '';
        document.getElementById('finalTranscript').setAttribute('data-saved', '');
        transcriptionHistory = [];
    }
}


// ============================================
// ðŸ”§ ×§×•×“ ×ž×•×›×Ÿ #3 - recognition.onresult
// ============================================
// ×”×—×œ×£ ××ª ×›×œ ×‘×œ×•×§ ×”-recognition.onresult (×ž-recognition.onstart ×¢×“ recognition.onerror)

recognition.onstart = () => {
    document.getElementById('statusIndicator').textContent = 'ðŸŽ§ ×ž××–×™×Ÿ... ×“×‘×¨ ×¢×›×©×™×•!';
};

recognition.onresult = (event) => {
    let interimTranscript = '';
    let finalTranscript = '';
    
    for (let i = event.resultIndex; i < event.results.length; i++) {
        const transcript = event.results[i][0].transcript;
        
        if (event.results[i].isFinal) {
            finalTranscript += transcript + ' ';
        } else {
            interimTranscript += transcript;
        }
    }
    
    // ×¢×“×›×Ÿ ××ª ×”×ª×¦×•×’×”
    if (interimTranscript.trim()) {
        const display = currentTranscriptionText ? 
            currentTranscriptionText + '\n\nðŸ’¬ ' + interimTranscript : 
            interimTranscript;
        document.getElementById('finalTranscript').textContent = display;
    } else if (currentTranscriptionText) {
        document.getElementById('finalTranscript').textContent = currentTranscriptionText;
    }
    
    // ×©×ž×•×¨ ××ª ×”×˜×§×¡×˜ ×”×¡×•×¤×™
    if (finalTranscript.trim()) {
        currentTranscriptionText = currentTranscriptionText ? 
            currentTranscriptionText + ' ' + finalTranscript.trim() : 
            finalTranscript.trim();
        
        document.getElementById('finalTranscript').textContent = currentTranscriptionText;
        
        transcriptionHistory.push({
            text: finalTranscript.trim(),
            time: getExactTime(),
            lang: currentVoiceLang
        });
        
        if (selectedTranslateLang && finalTranscript.trim()) {
            translateText(finalTranscript.trim(), selectedTranslateLang);
        }
    }
};

recognition.onend = () => {
    isRecording = false;
    document.getElementById('recordBtn').classList.remove('recording');
    document.getElementById('statusIndicator').textContent = 'âœ… Ready';
};

recognition.onerror = (event) => {
    document.getElementById('statusIndicator').textContent = 'âŒ Error: ' + event.error;
};


// ============================================
// ðŸ”§ ×§×•×“ ×ž×•×›×Ÿ #4 - saveTranscriptionTXT()
// ============================================
// ×”×—×œ×£ ××ª ×›×œ ×”×¤×•× ×§×¦×™×” ×”×–×•:

function saveTranscriptionTXT() {
    if (!currentTranscriptionText || currentTranscriptionText.trim().length === 0) {
        alert('××™×Ÿ ×˜×§×¡×˜ ×œ×©×ž×•×¨');
        return;
    }
    
    const allText = currentTranscriptionText.trim();
    const lines = allText.split('\n').filter(l => l.trim());
    
    const content = lines.map((line, i) => 
        `${i + 1}. ${line}`
    ).join('\n');
    
    const header = `×—×™-××ž×ª Transcription\n`;
    const metadata = `×©×¤×”: ${LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown'}\n×–×ž×Ÿ: ${new Date().toLocaleString('he-IL')}\n${'='.repeat(50)}\n`;
    const fullContent = header + metadata + content;
    
    const blob = new Blob([fullContent], { type: 'text/plain;charset=utf-8' });
    const link = document.createElement('a');
    link.href = URL.createObjectURL(blob);
    const filename = `transcription_${Date.now()}.txt`;
    link.download = filename;
    link.click();
    
    uploadedFiles.push({
        name: filename,
        time: getPrecisionTime(),
        type: 'txt',
        size: (blob.size / 1024).toFixed(2) + ' KB'
    });
    updateFilesList();
    addMessage(`ðŸ“„ ×©×ž×•×¨: ${filename}`, false);
}


// ============================================
// ðŸ”§ ×§×•×“ ×ž×•×›×Ÿ #5 - saveTranscriptionDOCX()
// ============================================
// ×”×—×œ×£ ××ª ×›×œ ×”×¤×•× ×§×¦×™×” ×”×–×•:

function saveTranscriptionDOCX() {
    if (!currentTranscriptionText || currentTranscriptionText.trim().length === 0) {
        alert('××™×Ÿ ×˜×§×¡×˜ ×œ×©×ž×•×¨');
        return;
    }
    
    const allText = currentTranscriptionText.trim();
    const lines = allText.split('\n').filter(l => l.trim());
    
    const sections = lines.map((line, i) => 
        new docx.Paragraph({
            text: `${i + 1}. ${line}`,
            spacing: { line: 360 }
        })
    );
    
    const doc = new docx.Document({
        sections: [{
            children: [
                new docx.Paragraph({
                    text: 'ðŸ’› ×—×™-××ž×ª - Transcription',
                    heading: docx.HeadingLevel.HEADING_1,
                    spacing: { after: 400 }
                }),
                new docx.Paragraph({
                    text: `×©×¤×”: ${LANGUAGES_CONFIG[currentVoiceLang]?.name || 'Unknown'}`,
                    spacing: { after: 200 }
                }),
                new docx.Paragraph({
                    text: `×–×ž×Ÿ: ${new Date().toLocaleString('he-IL')}`,
                    spacing: { after: 400 }
                }),
                ...sections
            ]
        }]
    });
    
    docx.Packer.toBlob(doc).then(blob => {
        const link = document.createElement('a');
        link.href = URL.createObjectURL(blob);
        const filename = `transcription_${Date.now()}.docx`;
        link.download = filename;
        link.click();
        
        uploadedFiles.push({
            name: filename,
            time: getPrecisionTime(),
            type: 'docx',
            size: (blob.size / 1024).toFixed(2) + ' KB'
        });
        updateFilesList();
        addMessage(`ðŸ“‹ ×©×ž×•×¨: ${filename}`, false);
    });
}
